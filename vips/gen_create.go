// Code generated by vipsgen. DO NOT EDIT.
package vips

// #include "gen_create.h"
import "C"

import "unsafe"

// Ensure imports are used.
var _ = unsafe.Pointer(nil)

// BlackOptions are optional parameters for black.
type BlackOptions struct {
	Bands *int
}

// vipsGenBlack calls the vips black operation.
// make a black image
func vipsGenBlack(width int, height int, opts *BlackOptions) (*C.VipsImage, error) {
	incOpCounter("black")

	var out_out *C.VipsImage

	var cOpts C.GenBlackOpts
	if opts != nil {
		if opts.Bands != nil {
			cOpts.has_bands = 1
			cOpts.bands = C.int(*opts.Bands)
		}
	}

	ret := C.gen_vips_black(C.int(width), C.int(height), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenBuildlut calls the vips buildlut operation.
// build a look-up table
func vipsGenBuildlut(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("buildlut")

	var out_out *C.VipsImage

	ret := C.gen_vips_buildlut(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// EyeOptions are optional parameters for eye.
type EyeOptions struct {
	Uchar *bool
	Factor *float64
}

// vipsGenEye calls the vips eye operation.
// make an image showing the eye's spatial response
func vipsGenEye(width int, height int, opts *EyeOptions) (*C.VipsImage, error) {
	incOpCounter("eye")

	var out_out *C.VipsImage

	var cOpts C.GenEyeOpts
	if opts != nil {
		if opts.Uchar != nil {
			cOpts.has_uchar = 1
			cOpts.uchar = C.int(boolToInt(*opts.Uchar))
		}
		if opts.Factor != nil {
			cOpts.has_factor = 1
			cOpts.factor = C.double(*opts.Factor)
		}
	}

	ret := C.gen_vips_eye(C.int(width), C.int(height), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenFractsurf calls the vips fractsurf operation.
// make a fractal surface
func vipsGenFractsurf(width int, height int, fractalDimension float64) (*C.VipsImage, error) {
	incOpCounter("fractsurf")

	var out_out *C.VipsImage

	ret := C.gen_vips_fractsurf(C.int(width), C.int(height), C.double(fractalDimension), &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// GaussmatOptions are optional parameters for gaussmat.
type GaussmatOptions struct {
	Separable *bool
	Precision *Precision
}

// vipsGenGaussmat calls the vips gaussmat operation.
// make a gaussian image
func vipsGenGaussmat(sigma float64, minAmpl float64, opts *GaussmatOptions) (*C.VipsImage, error) {
	incOpCounter("gaussmat")

	var out_out *C.VipsImage

	var cOpts C.GenGaussmatOpts
	if opts != nil {
		if opts.Separable != nil {
			cOpts.has_separable = 1
			cOpts.separable = C.int(boolToInt(*opts.Separable))
		}
		if opts.Precision != nil {
			cOpts.has_precision = 1
			cOpts.precision = C.VipsPrecision(*opts.Precision)
		}
	}

	ret := C.gen_vips_gaussmat(C.double(sigma), C.double(minAmpl), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// GaussnoiseOptions are optional parameters for gaussnoise.
type GaussnoiseOptions struct {
	Sigma *float64
	Mean *float64
	Seed *int
}

// vipsGenGaussnoise calls the vips gaussnoise operation.
// make a gaussnoise image
func vipsGenGaussnoise(width int, height int, opts *GaussnoiseOptions) (*C.VipsImage, error) {
	incOpCounter("gaussnoise")

	var out_out *C.VipsImage

	var cOpts C.GenGaussnoiseOpts
	if opts != nil {
		if opts.Sigma != nil {
			cOpts.has_sigma = 1
			cOpts.sigma = C.double(*opts.Sigma)
		}
		if opts.Mean != nil {
			cOpts.has_mean = 1
			cOpts.mean = C.double(*opts.Mean)
		}
		if opts.Seed != nil {
			cOpts.has_seed = 1
			cOpts.seed = C.int(*opts.Seed)
		}
	}

	ret := C.gen_vips_gaussnoise(C.int(width), C.int(height), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// GreyOptions are optional parameters for grey.
type GreyOptions struct {
	Uchar *bool
}

// vipsGenGrey calls the vips grey operation.
// make a grey ramp image
func vipsGenGrey(width int, height int, opts *GreyOptions) (*C.VipsImage, error) {
	incOpCounter("grey")

	var out_out *C.VipsImage

	var cOpts C.GenGreyOpts
	if opts != nil {
		if opts.Uchar != nil {
			cOpts.has_uchar = 1
			cOpts.uchar = C.int(boolToInt(*opts.Uchar))
		}
	}

	ret := C.gen_vips_grey(C.int(width), C.int(height), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// IdentityOptions are optional parameters for identity.
type IdentityOptions struct {
	Bands *int
	Ushort *bool
	Size *int
}

// vipsGenIdentity calls the vips identity operation.
// make a 1D image where pixel values are indexes
func vipsGenIdentity(opts *IdentityOptions) (*C.VipsImage, error) {
	incOpCounter("identity")

	var out_out *C.VipsImage

	var cOpts C.GenIdentityOpts
	if opts != nil {
		if opts.Bands != nil {
			cOpts.has_bands = 1
			cOpts.bands = C.int(*opts.Bands)
		}
		if opts.Ushort != nil {
			cOpts.has_ushort = 1
			cOpts.ushort = C.int(boolToInt(*opts.Ushort))
		}
		if opts.Size != nil {
			cOpts.has_size = 1
			cOpts.size = C.int(*opts.Size)
		}
	}

	ret := C.gen_vips_identity(&out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// InvertlutOptions are optional parameters for invertlut.
type InvertlutOptions struct {
	Size *int
}

// vipsGenInvertlut calls the vips invertlut operation.
// build an inverted look-up table
func vipsGenInvertlut(input *C.VipsImage, opts *InvertlutOptions) (*C.VipsImage, error) {
	incOpCounter("invertlut")

	var out_out *C.VipsImage

	var cOpts C.GenInvertlutOpts
	if opts != nil {
		if opts.Size != nil {
			cOpts.has_size = 1
			cOpts.size = C.int(*opts.Size)
		}
	}

	ret := C.gen_vips_invertlut(input, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// LogmatOptions are optional parameters for logmat.
type LogmatOptions struct {
	Separable *bool
	Precision *Precision
}

// vipsGenLogmat calls the vips logmat operation.
// make a Laplacian of Gaussian image
func vipsGenLogmat(sigma float64, minAmpl float64, opts *LogmatOptions) (*C.VipsImage, error) {
	incOpCounter("logmat")

	var out_out *C.VipsImage

	var cOpts C.GenLogmatOpts
	if opts != nil {
		if opts.Separable != nil {
			cOpts.has_separable = 1
			cOpts.separable = C.int(boolToInt(*opts.Separable))
		}
		if opts.Precision != nil {
			cOpts.has_precision = 1
			cOpts.precision = C.VipsPrecision(*opts.Precision)
		}
	}

	ret := C.gen_vips_logmat(C.double(sigma), C.double(minAmpl), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// MaskButterworthOptions are optional parameters for mask_butterworth.
type MaskButterworthOptions struct {
	Uchar *bool
	Nodc *bool
	Reject *bool
	Optical *bool
}

// vipsGenMaskButterworth calls the vips mask_butterworth operation.
// make a butterworth filter
func vipsGenMaskButterworth(width int, height int, order float64, frequencyCutoff float64, amplitudeCutoff float64, opts *MaskButterworthOptions) (*C.VipsImage, error) {
	incOpCounter("mask_butterworth")

	var out_out *C.VipsImage

	var cOpts C.GenMaskButterworthOpts
	if opts != nil {
		if opts.Uchar != nil {
			cOpts.has_uchar = 1
			cOpts.uchar = C.int(boolToInt(*opts.Uchar))
		}
		if opts.Nodc != nil {
			cOpts.has_nodc = 1
			cOpts.nodc = C.int(boolToInt(*opts.Nodc))
		}
		if opts.Reject != nil {
			cOpts.has_reject = 1
			cOpts.reject = C.int(boolToInt(*opts.Reject))
		}
		if opts.Optical != nil {
			cOpts.has_optical = 1
			cOpts.optical = C.int(boolToInt(*opts.Optical))
		}
	}

	ret := C.gen_vips_mask_butterworth(C.int(width), C.int(height), C.double(order), C.double(frequencyCutoff), C.double(amplitudeCutoff), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// MaskButterworthBandOptions are optional parameters for mask_butterworth_band.
type MaskButterworthBandOptions struct {
	Uchar *bool
	Nodc *bool
	Reject *bool
	Optical *bool
}

// vipsGenMaskButterworthBand calls the vips mask_butterworth_band operation.
// make a butterworth_band filter
func vipsGenMaskButterworthBand(width int, height int, order float64, frequencyCutoffX float64, frequencyCutoffY float64, radius float64, amplitudeCutoff float64, opts *MaskButterworthBandOptions) (*C.VipsImage, error) {
	incOpCounter("mask_butterworth_band")

	var out_out *C.VipsImage

	var cOpts C.GenMaskButterworthBandOpts
	if opts != nil {
		if opts.Uchar != nil {
			cOpts.has_uchar = 1
			cOpts.uchar = C.int(boolToInt(*opts.Uchar))
		}
		if opts.Nodc != nil {
			cOpts.has_nodc = 1
			cOpts.nodc = C.int(boolToInt(*opts.Nodc))
		}
		if opts.Reject != nil {
			cOpts.has_reject = 1
			cOpts.reject = C.int(boolToInt(*opts.Reject))
		}
		if opts.Optical != nil {
			cOpts.has_optical = 1
			cOpts.optical = C.int(boolToInt(*opts.Optical))
		}
	}

	ret := C.gen_vips_mask_butterworth_band(C.int(width), C.int(height), C.double(order), C.double(frequencyCutoffX), C.double(frequencyCutoffY), C.double(radius), C.double(amplitudeCutoff), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// MaskButterworthRingOptions are optional parameters for mask_butterworth_ring.
type MaskButterworthRingOptions struct {
	Uchar *bool
	Nodc *bool
	Reject *bool
	Optical *bool
}

// vipsGenMaskButterworthRing calls the vips mask_butterworth_ring operation.
// make a butterworth ring filter
func vipsGenMaskButterworthRing(width int, height int, order float64, frequencyCutoff float64, amplitudeCutoff float64, ringwidth float64, opts *MaskButterworthRingOptions) (*C.VipsImage, error) {
	incOpCounter("mask_butterworth_ring")

	var out_out *C.VipsImage

	var cOpts C.GenMaskButterworthRingOpts
	if opts != nil {
		if opts.Uchar != nil {
			cOpts.has_uchar = 1
			cOpts.uchar = C.int(boolToInt(*opts.Uchar))
		}
		if opts.Nodc != nil {
			cOpts.has_nodc = 1
			cOpts.nodc = C.int(boolToInt(*opts.Nodc))
		}
		if opts.Reject != nil {
			cOpts.has_reject = 1
			cOpts.reject = C.int(boolToInt(*opts.Reject))
		}
		if opts.Optical != nil {
			cOpts.has_optical = 1
			cOpts.optical = C.int(boolToInt(*opts.Optical))
		}
	}

	ret := C.gen_vips_mask_butterworth_ring(C.int(width), C.int(height), C.double(order), C.double(frequencyCutoff), C.double(amplitudeCutoff), C.double(ringwidth), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// MaskFractalOptions are optional parameters for mask_fractal.
type MaskFractalOptions struct {
	Uchar *bool
	Nodc *bool
	Reject *bool
	Optical *bool
}

// vipsGenMaskFractal calls the vips mask_fractal operation.
// make fractal filter
func vipsGenMaskFractal(width int, height int, fractalDimension float64, opts *MaskFractalOptions) (*C.VipsImage, error) {
	incOpCounter("mask_fractal")

	var out_out *C.VipsImage

	var cOpts C.GenMaskFractalOpts
	if opts != nil {
		if opts.Uchar != nil {
			cOpts.has_uchar = 1
			cOpts.uchar = C.int(boolToInt(*opts.Uchar))
		}
		if opts.Nodc != nil {
			cOpts.has_nodc = 1
			cOpts.nodc = C.int(boolToInt(*opts.Nodc))
		}
		if opts.Reject != nil {
			cOpts.has_reject = 1
			cOpts.reject = C.int(boolToInt(*opts.Reject))
		}
		if opts.Optical != nil {
			cOpts.has_optical = 1
			cOpts.optical = C.int(boolToInt(*opts.Optical))
		}
	}

	ret := C.gen_vips_mask_fractal(C.int(width), C.int(height), C.double(fractalDimension), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// MaskGaussianOptions are optional parameters for mask_gaussian.
type MaskGaussianOptions struct {
	Uchar *bool
	Nodc *bool
	Reject *bool
	Optical *bool
}

// vipsGenMaskGaussian calls the vips mask_gaussian operation.
// make a gaussian filter
func vipsGenMaskGaussian(width int, height int, frequencyCutoff float64, amplitudeCutoff float64, opts *MaskGaussianOptions) (*C.VipsImage, error) {
	incOpCounter("mask_gaussian")

	var out_out *C.VipsImage

	var cOpts C.GenMaskGaussianOpts
	if opts != nil {
		if opts.Uchar != nil {
			cOpts.has_uchar = 1
			cOpts.uchar = C.int(boolToInt(*opts.Uchar))
		}
		if opts.Nodc != nil {
			cOpts.has_nodc = 1
			cOpts.nodc = C.int(boolToInt(*opts.Nodc))
		}
		if opts.Reject != nil {
			cOpts.has_reject = 1
			cOpts.reject = C.int(boolToInt(*opts.Reject))
		}
		if opts.Optical != nil {
			cOpts.has_optical = 1
			cOpts.optical = C.int(boolToInt(*opts.Optical))
		}
	}

	ret := C.gen_vips_mask_gaussian(C.int(width), C.int(height), C.double(frequencyCutoff), C.double(amplitudeCutoff), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// MaskGaussianBandOptions are optional parameters for mask_gaussian_band.
type MaskGaussianBandOptions struct {
	Uchar *bool
	Nodc *bool
	Reject *bool
	Optical *bool
}

// vipsGenMaskGaussianBand calls the vips mask_gaussian_band operation.
// make a gaussian filter
func vipsGenMaskGaussianBand(width int, height int, frequencyCutoffX float64, frequencyCutoffY float64, radius float64, amplitudeCutoff float64, opts *MaskGaussianBandOptions) (*C.VipsImage, error) {
	incOpCounter("mask_gaussian_band")

	var out_out *C.VipsImage

	var cOpts C.GenMaskGaussianBandOpts
	if opts != nil {
		if opts.Uchar != nil {
			cOpts.has_uchar = 1
			cOpts.uchar = C.int(boolToInt(*opts.Uchar))
		}
		if opts.Nodc != nil {
			cOpts.has_nodc = 1
			cOpts.nodc = C.int(boolToInt(*opts.Nodc))
		}
		if opts.Reject != nil {
			cOpts.has_reject = 1
			cOpts.reject = C.int(boolToInt(*opts.Reject))
		}
		if opts.Optical != nil {
			cOpts.has_optical = 1
			cOpts.optical = C.int(boolToInt(*opts.Optical))
		}
	}

	ret := C.gen_vips_mask_gaussian_band(C.int(width), C.int(height), C.double(frequencyCutoffX), C.double(frequencyCutoffY), C.double(radius), C.double(amplitudeCutoff), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// MaskGaussianRingOptions are optional parameters for mask_gaussian_ring.
type MaskGaussianRingOptions struct {
	Uchar *bool
	Nodc *bool
	Reject *bool
	Optical *bool
}

// vipsGenMaskGaussianRing calls the vips mask_gaussian_ring operation.
// make a gaussian ring filter
func vipsGenMaskGaussianRing(width int, height int, frequencyCutoff float64, amplitudeCutoff float64, ringwidth float64, opts *MaskGaussianRingOptions) (*C.VipsImage, error) {
	incOpCounter("mask_gaussian_ring")

	var out_out *C.VipsImage

	var cOpts C.GenMaskGaussianRingOpts
	if opts != nil {
		if opts.Uchar != nil {
			cOpts.has_uchar = 1
			cOpts.uchar = C.int(boolToInt(*opts.Uchar))
		}
		if opts.Nodc != nil {
			cOpts.has_nodc = 1
			cOpts.nodc = C.int(boolToInt(*opts.Nodc))
		}
		if opts.Reject != nil {
			cOpts.has_reject = 1
			cOpts.reject = C.int(boolToInt(*opts.Reject))
		}
		if opts.Optical != nil {
			cOpts.has_optical = 1
			cOpts.optical = C.int(boolToInt(*opts.Optical))
		}
	}

	ret := C.gen_vips_mask_gaussian_ring(C.int(width), C.int(height), C.double(frequencyCutoff), C.double(amplitudeCutoff), C.double(ringwidth), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// MaskIdealOptions are optional parameters for mask_ideal.
type MaskIdealOptions struct {
	Uchar *bool
	Nodc *bool
	Reject *bool
	Optical *bool
}

// vipsGenMaskIdeal calls the vips mask_ideal operation.
// make an ideal filter
func vipsGenMaskIdeal(width int, height int, frequencyCutoff float64, opts *MaskIdealOptions) (*C.VipsImage, error) {
	incOpCounter("mask_ideal")

	var out_out *C.VipsImage

	var cOpts C.GenMaskIdealOpts
	if opts != nil {
		if opts.Uchar != nil {
			cOpts.has_uchar = 1
			cOpts.uchar = C.int(boolToInt(*opts.Uchar))
		}
		if opts.Nodc != nil {
			cOpts.has_nodc = 1
			cOpts.nodc = C.int(boolToInt(*opts.Nodc))
		}
		if opts.Reject != nil {
			cOpts.has_reject = 1
			cOpts.reject = C.int(boolToInt(*opts.Reject))
		}
		if opts.Optical != nil {
			cOpts.has_optical = 1
			cOpts.optical = C.int(boolToInt(*opts.Optical))
		}
	}

	ret := C.gen_vips_mask_ideal(C.int(width), C.int(height), C.double(frequencyCutoff), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// MaskIdealBandOptions are optional parameters for mask_ideal_band.
type MaskIdealBandOptions struct {
	Uchar *bool
	Nodc *bool
	Reject *bool
	Optical *bool
}

// vipsGenMaskIdealBand calls the vips mask_ideal_band operation.
// make an ideal band filter
func vipsGenMaskIdealBand(width int, height int, frequencyCutoffX float64, frequencyCutoffY float64, radius float64, opts *MaskIdealBandOptions) (*C.VipsImage, error) {
	incOpCounter("mask_ideal_band")

	var out_out *C.VipsImage

	var cOpts C.GenMaskIdealBandOpts
	if opts != nil {
		if opts.Uchar != nil {
			cOpts.has_uchar = 1
			cOpts.uchar = C.int(boolToInt(*opts.Uchar))
		}
		if opts.Nodc != nil {
			cOpts.has_nodc = 1
			cOpts.nodc = C.int(boolToInt(*opts.Nodc))
		}
		if opts.Reject != nil {
			cOpts.has_reject = 1
			cOpts.reject = C.int(boolToInt(*opts.Reject))
		}
		if opts.Optical != nil {
			cOpts.has_optical = 1
			cOpts.optical = C.int(boolToInt(*opts.Optical))
		}
	}

	ret := C.gen_vips_mask_ideal_band(C.int(width), C.int(height), C.double(frequencyCutoffX), C.double(frequencyCutoffY), C.double(radius), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// MaskIdealRingOptions are optional parameters for mask_ideal_ring.
type MaskIdealRingOptions struct {
	Uchar *bool
	Nodc *bool
	Reject *bool
	Optical *bool
}

// vipsGenMaskIdealRing calls the vips mask_ideal_ring operation.
// make an ideal ring filter
func vipsGenMaskIdealRing(width int, height int, frequencyCutoff float64, ringwidth float64, opts *MaskIdealRingOptions) (*C.VipsImage, error) {
	incOpCounter("mask_ideal_ring")

	var out_out *C.VipsImage

	var cOpts C.GenMaskIdealRingOpts
	if opts != nil {
		if opts.Uchar != nil {
			cOpts.has_uchar = 1
			cOpts.uchar = C.int(boolToInt(*opts.Uchar))
		}
		if opts.Nodc != nil {
			cOpts.has_nodc = 1
			cOpts.nodc = C.int(boolToInt(*opts.Nodc))
		}
		if opts.Reject != nil {
			cOpts.has_reject = 1
			cOpts.reject = C.int(boolToInt(*opts.Reject))
		}
		if opts.Optical != nil {
			cOpts.has_optical = 1
			cOpts.optical = C.int(boolToInt(*opts.Optical))
		}
	}

	ret := C.gen_vips_mask_ideal_ring(C.int(width), C.int(height), C.double(frequencyCutoff), C.double(ringwidth), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// PerlinOptions are optional parameters for perlin.
type PerlinOptions struct {
	CellSize *int
	Uchar *bool
	Seed *int
}

// vipsGenPerlin calls the vips perlin operation.
// make a perlin noise image
func vipsGenPerlin(width int, height int, opts *PerlinOptions) (*C.VipsImage, error) {
	incOpCounter("perlin")

	var out_out *C.VipsImage

	var cOpts C.GenPerlinOpts
	if opts != nil {
		if opts.CellSize != nil {
			cOpts.has_cellSize = 1
			cOpts.cellSize = C.int(*opts.CellSize)
		}
		if opts.Uchar != nil {
			cOpts.has_uchar = 1
			cOpts.uchar = C.int(boolToInt(*opts.Uchar))
		}
		if opts.Seed != nil {
			cOpts.has_seed = 1
			cOpts.seed = C.int(*opts.Seed)
		}
	}

	ret := C.gen_vips_perlin(C.int(width), C.int(height), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// SinesOptions are optional parameters for sines.
type SinesOptions struct {
	Uchar *bool
	Hfreq *float64
	Vfreq *float64
}

// vipsGenSines calls the vips sines operation.
// make a 2D sine wave
func vipsGenSines(width int, height int, opts *SinesOptions) (*C.VipsImage, error) {
	incOpCounter("sines")

	var out_out *C.VipsImage

	var cOpts C.GenSinesOpts
	if opts != nil {
		if opts.Uchar != nil {
			cOpts.has_uchar = 1
			cOpts.uchar = C.int(boolToInt(*opts.Uchar))
		}
		if opts.Hfreq != nil {
			cOpts.has_hfreq = 1
			cOpts.hfreq = C.double(*opts.Hfreq)
		}
		if opts.Vfreq != nil {
			cOpts.has_vfreq = 1
			cOpts.vfreq = C.double(*opts.Vfreq)
		}
	}

	ret := C.gen_vips_sines(C.int(width), C.int(height), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// TonelutOptions are optional parameters for tonelut.
type TonelutOptions struct {
	InMax *int
	OutMax *int
	Lb *float64
	Lw *float64
	Ps *float64
	Pm *float64
	Ph *float64
	S *float64
	M *float64
	H *float64
}

// vipsGenTonelut calls the vips tonelut operation.
// build a look-up table
func vipsGenTonelut(opts *TonelutOptions) (*C.VipsImage, error) {
	incOpCounter("tonelut")

	var out_out *C.VipsImage

	var cOpts C.GenTonelutOpts
	if opts != nil {
		if opts.InMax != nil {
			cOpts.has_inMax = 1
			cOpts.inMax = C.int(*opts.InMax)
		}
		if opts.OutMax != nil {
			cOpts.has_outMax = 1
			cOpts.outMax = C.int(*opts.OutMax)
		}
		if opts.Lb != nil {
			cOpts.has_Lb = 1
			cOpts.Lb = C.double(*opts.Lb)
		}
		if opts.Lw != nil {
			cOpts.has_Lw = 1
			cOpts.Lw = C.double(*opts.Lw)
		}
		if opts.Ps != nil {
			cOpts.has_Ps = 1
			cOpts.Ps = C.double(*opts.Ps)
		}
		if opts.Pm != nil {
			cOpts.has_Pm = 1
			cOpts.Pm = C.double(*opts.Pm)
		}
		if opts.Ph != nil {
			cOpts.has_Ph = 1
			cOpts.Ph = C.double(*opts.Ph)
		}
		if opts.S != nil {
			cOpts.has_S = 1
			cOpts.S = C.double(*opts.S)
		}
		if opts.M != nil {
			cOpts.has_M = 1
			cOpts.M = C.double(*opts.M)
		}
		if opts.H != nil {
			cOpts.has_H = 1
			cOpts.H = C.double(*opts.H)
		}
	}

	ret := C.gen_vips_tonelut(&out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// WorleyOptions are optional parameters for worley.
type WorleyOptions struct {
	CellSize *int
	Seed *int
}

// vipsGenWorley calls the vips worley operation.
// make a worley noise image
func vipsGenWorley(width int, height int, opts *WorleyOptions) (*C.VipsImage, error) {
	incOpCounter("worley")

	var out_out *C.VipsImage

	var cOpts C.GenWorleyOpts
	if opts != nil {
		if opts.CellSize != nil {
			cOpts.has_cellSize = 1
			cOpts.cellSize = C.int(*opts.CellSize)
		}
		if opts.Seed != nil {
			cOpts.has_seed = 1
			cOpts.seed = C.int(*opts.Seed)
		}
	}

	ret := C.gen_vips_worley(C.int(width), C.int(height), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// XyzOptions are optional parameters for xyz.
type XyzOptions struct {
	Csize *int
	Dsize *int
	Esize *int
}

// vipsGenXyz calls the vips xyz operation.
// make an image where pixel values are coordinates
func vipsGenXyz(width int, height int, opts *XyzOptions) (*C.VipsImage, error) {
	incOpCounter("xyz")

	var out_out *C.VipsImage

	var cOpts C.GenXyzOpts
	if opts != nil {
		if opts.Csize != nil {
			cOpts.has_csize = 1
			cOpts.csize = C.int(*opts.Csize)
		}
		if opts.Dsize != nil {
			cOpts.has_dsize = 1
			cOpts.dsize = C.int(*opts.Dsize)
		}
		if opts.Esize != nil {
			cOpts.has_esize = 1
			cOpts.esize = C.int(*opts.Esize)
		}
	}

	ret := C.gen_vips_xyz(C.int(width), C.int(height), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// ZoneOptions are optional parameters for zone.
type ZoneOptions struct {
	Uchar *bool
}

// vipsGenZone calls the vips zone operation.
// make a zone plate
func vipsGenZone(width int, height int, opts *ZoneOptions) (*C.VipsImage, error) {
	incOpCounter("zone")

	var out_out *C.VipsImage

	var cOpts C.GenZoneOpts
	if opts != nil {
		if opts.Uchar != nil {
			cOpts.has_uchar = 1
			cOpts.uchar = C.int(boolToInt(*opts.Uchar))
		}
	}

	ret := C.gen_vips_zone(C.int(width), C.int(height), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

