// Code generated by vipsgen. DO NOT EDIT.
package vips

// #include "gen_conversion.h"
import "C"

import (
	"runtime"
	"unsafe"
)

// Ensure imports are used.
var _ = unsafe.Pointer(nil)

// ArrayjoinOptions are optional parameters for arrayjoin.
type ArrayjoinOptions struct {
	Across *int
	Shim *int
	Background []float64
	Halign *Align
	Valign *Align
	Hspacing *int
	Vspacing *int
}

// vipsGenArrayjoin calls the vips arrayjoin operation.
// join an array of images
func vipsGenArrayjoin(input []*C.VipsImage, opts *ArrayjoinOptions) (*C.VipsImage, error) {
	incOpCounter("arrayjoin")

	var out_out *C.VipsImage

	var cOpts C.GenArrayjoinOpts
	var pinner runtime.Pinner
	defer pinner.Unpin()
	if opts != nil {
		if opts.Across != nil {
			cOpts.has_across = 1
			cOpts.across = C.int(*opts.Across)
		}
		if opts.Shim != nil {
			cOpts.has_shim = 1
			cOpts.shim = C.int(*opts.Shim)
		}
		if opts.Background != nil {
			cOpts.has_background = 1
			pinner.Pin(&opts.Background[0])
			cOpts.background = (*C.double)(unsafe.Pointer(&opts.Background[0]))
			cOpts.background_n = C.int(len(opts.Background))
		}
		if opts.Halign != nil {
			cOpts.has_halign = 1
			cOpts.halign = C.VipsAlign(*opts.Halign)
		}
		if opts.Valign != nil {
			cOpts.has_valign = 1
			cOpts.valign = C.VipsAlign(*opts.Valign)
		}
		if opts.Hspacing != nil {
			cOpts.has_hspacing = 1
			cOpts.hspacing = C.int(*opts.Hspacing)
		}
		if opts.Vspacing != nil {
			cOpts.has_vspacing = 1
			cOpts.vspacing = C.int(*opts.Vspacing)
		}
	}

	ret := C.gen_vips_arrayjoin((**C.VipsImage)(unsafe.Pointer(&input[0])), C.int(len(input)), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenAutorot calls the vips autorot operation.
// autorotate image by exif tag
func vipsGenAutorot(input *C.VipsImage) (*C.VipsImage, Angle, bool, error) {
	incOpCounter("autorot")

	var out_out *C.VipsImage
	var out_angle C.int
	var out_flip C.int

	ret := C.gen_vips_autorot(input, &out_out, &out_angle, &out_flip)
	if ret != 0 {
		return nil, 0, false, handleImageError(out_out)
	}

	return out_out, Angle(out_angle), out_flip != 0, nil
}

// vipsGenBandbool calls the vips bandbool operation.
// boolean operation across image bands
func vipsGenBandbool(input *C.VipsImage, boolean OperationBoolean) (*C.VipsImage, error) {
	incOpCounter("bandbool")

	var out_out *C.VipsImage

	ret := C.gen_vips_bandbool(input, C.VipsOperationBoolean(boolean), &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// BandfoldOptions are optional parameters for bandfold.
type BandfoldOptions struct {
	Factor *int
}

// vipsGenBandfold calls the vips bandfold operation.
// fold up x axis into bands
func vipsGenBandfold(input *C.VipsImage, opts *BandfoldOptions) (*C.VipsImage, error) {
	incOpCounter("bandfold")

	var out_out *C.VipsImage

	var cOpts C.GenBandfoldOpts
	if opts != nil {
		if opts.Factor != nil {
			cOpts.has_factor = 1
			cOpts.factor = C.int(*opts.Factor)
		}
	}

	ret := C.gen_vips_bandfold(input, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenBandjoin calls the vips bandjoin operation.
// bandwise join a set of images
func vipsGenBandjoin(input []*C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("bandjoin")

	var out_out *C.VipsImage

	ret := C.gen_vips_bandjoin((**C.VipsImage)(unsafe.Pointer(&input[0])), C.int(len(input)), &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenBandjoinConst calls the vips bandjoin_const operation.
// append a constant band to an image
func vipsGenBandjoinConst(input *C.VipsImage, c []float64) (*C.VipsImage, error) {
	incOpCounter("bandjoin_const")

	var out_out *C.VipsImage

	ret := C.gen_vips_bandjoin_const(input, (*C.double)(unsafe.Pointer(&c[0])), C.int(len(c)), &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenBandmean calls the vips bandmean operation.
// band-wise average
func vipsGenBandmean(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("bandmean")

	var out_out *C.VipsImage

	ret := C.gen_vips_bandmean(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// BandrankOptions are optional parameters for bandrank.
type BandrankOptions struct {
	Index *int
}

// vipsGenBandrank calls the vips bandrank operation.
// band-wise rank of a set of images
func vipsGenBandrank(input []*C.VipsImage, opts *BandrankOptions) (*C.VipsImage, error) {
	incOpCounter("bandrank")

	var out_out *C.VipsImage

	var cOpts C.GenBandrankOpts
	if opts != nil {
		if opts.Index != nil {
			cOpts.has_index = 1
			cOpts.index = C.int(*opts.Index)
		}
	}

	ret := C.gen_vips_bandrank((**C.VipsImage)(unsafe.Pointer(&input[0])), C.int(len(input)), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// BandunfoldOptions are optional parameters for bandunfold.
type BandunfoldOptions struct {
	Factor *int
}

// vipsGenBandunfold calls the vips bandunfold operation.
// unfold image bands into x axis
func vipsGenBandunfold(input *C.VipsImage, opts *BandunfoldOptions) (*C.VipsImage, error) {
	incOpCounter("bandunfold")

	var out_out *C.VipsImage

	var cOpts C.GenBandunfoldOpts
	if opts != nil {
		if opts.Factor != nil {
			cOpts.has_factor = 1
			cOpts.factor = C.int(*opts.Factor)
		}
	}

	ret := C.gen_vips_bandunfold(input, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenByteswap calls the vips byteswap operation.
// byteswap an image
func vipsGenByteswap(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("byteswap")

	var out_out *C.VipsImage

	ret := C.gen_vips_byteswap(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// CacheOptions are optional parameters for cache.
type CacheOptions struct {
	MaxTiles *int
	TileHeight *int
	TileWidth *int
}

// vipsGenCache calls the vips cache operation.
// cache an image
func vipsGenCache(input *C.VipsImage, opts *CacheOptions) (*C.VipsImage, error) {
	incOpCounter("cache")

	var out_out *C.VipsImage

	var cOpts C.GenCacheOpts
	if opts != nil {
		if opts.MaxTiles != nil {
			cOpts.has_maxTiles = 1
			cOpts.maxTiles = C.int(*opts.MaxTiles)
		}
		if opts.TileHeight != nil {
			cOpts.has_tileHeight = 1
			cOpts.tileHeight = C.int(*opts.TileHeight)
		}
		if opts.TileWidth != nil {
			cOpts.has_tileWidth = 1
			cOpts.tileWidth = C.int(*opts.TileWidth)
		}
	}

	ret := C.gen_vips_cache(input, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// CastOptions are optional parameters for cast.
type CastOptions struct {
	Shift *bool
}

// vipsGenCast calls the vips cast operation.
// cast an image
func vipsGenCast(input *C.VipsImage, format BandFormat, opts *CastOptions) (*C.VipsImage, error) {
	incOpCounter("cast")

	var out_out *C.VipsImage

	var cOpts C.GenCastOpts
	if opts != nil {
		if opts.Shift != nil {
			cOpts.has_shift = 1
			cOpts.shift = C.int(boolToInt(*opts.Shift))
		}
	}

	ret := C.gen_vips_cast(input, C.VipsBandFormat(format), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// Composite2Options are optional parameters for composite2.
type Composite2Options struct {
	X *int
	Y *int
	CompositingSpace *Interpretation
	Premultiplied *bool
}

// vipsGenComposite2 calls the vips composite2 operation.
// blend a pair of images with a blend mode
func vipsGenComposite2(base *C.VipsImage, overlay *C.VipsImage, mode BlendMode, opts *Composite2Options) (*C.VipsImage, error) {
	incOpCounter("composite2")

	var out_out *C.VipsImage

	var cOpts C.GenComposite2Opts
	if opts != nil {
		if opts.X != nil {
			cOpts.has_x = 1
			cOpts.x = C.int(*opts.X)
		}
		if opts.Y != nil {
			cOpts.has_y = 1
			cOpts.y = C.int(*opts.Y)
		}
		if opts.CompositingSpace != nil {
			cOpts.has_compositingSpace = 1
			cOpts.compositingSpace = C.VipsInterpretation(*opts.CompositingSpace)
		}
		if opts.Premultiplied != nil {
			cOpts.has_premultiplied = 1
			cOpts.premultiplied = C.int(boolToInt(*opts.Premultiplied))
		}
	}

	ret := C.gen_vips_composite2(base, overlay, C.VipsBlendMode(mode), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// CopyOptions are optional parameters for copy.
type CopyOptions struct {
	Width *int
	Height *int
	Bands *int
	Format *BandFormat
	Coding *Coding
	Interpretation *Interpretation
	Xres *float64
	Yres *float64
	Xoffset *int
	Yoffset *int
}

// vipsGenCopy calls the vips copy operation.
// copy an image
func vipsGenCopy(input *C.VipsImage, opts *CopyOptions) (*C.VipsImage, error) {
	incOpCounter("copy")

	var out_out *C.VipsImage

	var cOpts C.GenCopyOpts
	if opts != nil {
		if opts.Width != nil {
			cOpts.has_width = 1
			cOpts.width = C.int(*opts.Width)
		}
		if opts.Height != nil {
			cOpts.has_height = 1
			cOpts.height = C.int(*opts.Height)
		}
		if opts.Bands != nil {
			cOpts.has_bands = 1
			cOpts.bands = C.int(*opts.Bands)
		}
		if opts.Format != nil {
			cOpts.has_format = 1
			cOpts.format = C.VipsBandFormat(*opts.Format)
		}
		if opts.Coding != nil {
			cOpts.has_coding = 1
			cOpts.coding = C.VipsCoding(*opts.Coding)
		}
		if opts.Interpretation != nil {
			cOpts.has_interpretation = 1
			cOpts.interpretation = C.VipsInterpretation(*opts.Interpretation)
		}
		if opts.Xres != nil {
			cOpts.has_xres = 1
			cOpts.xres = C.double(*opts.Xres)
		}
		if opts.Yres != nil {
			cOpts.has_yres = 1
			cOpts.yres = C.double(*opts.Yres)
		}
		if opts.Xoffset != nil {
			cOpts.has_xoffset = 1
			cOpts.xoffset = C.int(*opts.Xoffset)
		}
		if opts.Yoffset != nil {
			cOpts.has_yoffset = 1
			cOpts.yoffset = C.int(*opts.Yoffset)
		}
	}

	ret := C.gen_vips_copy(input, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenExtractArea calls the vips extract_area operation.
// extract an area from an image
func vipsGenExtractArea(input *C.VipsImage, left int, top int, width int, height int) (*C.VipsImage, error) {
	incOpCounter("extract_area")

	var out_out *C.VipsImage

	ret := C.gen_vips_extract_area(input, C.int(left), C.int(top), C.int(width), C.int(height), &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// ExtractBandOptions are optional parameters for extract_band.
type ExtractBandOptions struct {
	N *int
}

// vipsGenExtractBand calls the vips extract_band operation.
// extract band from an image
func vipsGenExtractBand(input *C.VipsImage, band int, opts *ExtractBandOptions) (*C.VipsImage, error) {
	incOpCounter("extract_band")

	var out_out *C.VipsImage

	var cOpts C.GenExtractBandOpts
	if opts != nil {
		if opts.N != nil {
			cOpts.has_n = 1
			cOpts.n = C.int(*opts.N)
		}
	}

	ret := C.gen_vips_extract_band(input, C.int(band), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenFalsecolour calls the vips falsecolour operation.
// false-color an image
func vipsGenFalsecolour(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("falsecolour")

	var out_out *C.VipsImage

	ret := C.gen_vips_falsecolour(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// FlattenOptions are optional parameters for flatten.
type FlattenOptions struct {
	Background []float64
	MaxAlpha *float64
}

// vipsGenFlatten calls the vips flatten operation.
// flatten alpha out of an image
func vipsGenFlatten(input *C.VipsImage, opts *FlattenOptions) (*C.VipsImage, error) {
	incOpCounter("flatten")

	var out_out *C.VipsImage

	var cOpts C.GenFlattenOpts
	var pinner runtime.Pinner
	defer pinner.Unpin()
	if opts != nil {
		if opts.Background != nil {
			cOpts.has_background = 1
			pinner.Pin(&opts.Background[0])
			cOpts.background = (*C.double)(unsafe.Pointer(&opts.Background[0]))
			cOpts.background_n = C.int(len(opts.Background))
		}
		if opts.MaxAlpha != nil {
			cOpts.has_maxAlpha = 1
			cOpts.maxAlpha = C.double(*opts.MaxAlpha)
		}
	}

	ret := C.gen_vips_flatten(input, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenFlip calls the vips flip operation.
// flip an image
func vipsGenFlip(input *C.VipsImage, direction Direction) (*C.VipsImage, error) {
	incOpCounter("flip")

	var out_out *C.VipsImage

	ret := C.gen_vips_flip(input, C.VipsDirection(direction), &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// GammaOptions are optional parameters for gamma.
type GammaOptions struct {
	Exponent *float64
}

// vipsGenGamma calls the vips gamma operation.
// gamma an image
func vipsGenGamma(input *C.VipsImage, opts *GammaOptions) (*C.VipsImage, error) {
	incOpCounter("gamma")

	var out_out *C.VipsImage

	var cOpts C.GenGammaOpts
	if opts != nil {
		if opts.Exponent != nil {
			cOpts.has_exponent = 1
			cOpts.exponent = C.double(*opts.Exponent)
		}
	}

	ret := C.gen_vips_gamma(input, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// GravityOptions are optional parameters for gravity.
type GravityOptions struct {
	Extend *ExtendStrategy
	Background []float64
}

// vipsGenGravity calls the vips gravity operation.
// place an image within a larger image with a certain gravity
func vipsGenGravity(input *C.VipsImage, direction Gravity, width int, height int, opts *GravityOptions) (*C.VipsImage, error) {
	incOpCounter("gravity")

	var out_out *C.VipsImage

	var cOpts C.GenGravityOpts
	var pinner runtime.Pinner
	defer pinner.Unpin()
	if opts != nil {
		if opts.Extend != nil {
			cOpts.has_extend = 1
			cOpts.extend = C.VipsExtend(*opts.Extend)
		}
		if opts.Background != nil {
			cOpts.has_background = 1
			pinner.Pin(&opts.Background[0])
			cOpts.background = (*C.double)(unsafe.Pointer(&opts.Background[0]))
			cOpts.background_n = C.int(len(opts.Background))
		}
	}

	ret := C.gen_vips_gravity(input, C.VipsCompassDirection(direction), C.int(width), C.int(height), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenGrid calls the vips grid operation.
// grid an image
func vipsGenGrid(input *C.VipsImage, tileHeight int, across int, down int) (*C.VipsImage, error) {
	incOpCounter("grid")

	var out_out *C.VipsImage

	ret := C.gen_vips_grid(input, C.int(tileHeight), C.int(across), C.int(down), &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// IfthenelseOptions are optional parameters for ifthenelse.
type IfthenelseOptions struct {
	Blend *bool
}

// vipsGenIfthenelse calls the vips ifthenelse operation.
// ifthenelse an image
func vipsGenIfthenelse(cond *C.VipsImage, in1 *C.VipsImage, in2 *C.VipsImage, opts *IfthenelseOptions) (*C.VipsImage, error) {
	incOpCounter("ifthenelse")

	var out_out *C.VipsImage

	var cOpts C.GenIfthenelseOpts
	if opts != nil {
		if opts.Blend != nil {
			cOpts.has_blend = 1
			cOpts.blend = C.int(boolToInt(*opts.Blend))
		}
	}

	ret := C.gen_vips_ifthenelse(cond, in1, in2, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// InsertOptions are optional parameters for insert.
type InsertOptions struct {
	Expand *bool
	Background []float64
}

// vipsGenInsert calls the vips insert operation.
// insert image @sub into @main at @x, @y
func vipsGenInsert(main *C.VipsImage, sub *C.VipsImage, x int, y int, opts *InsertOptions) (*C.VipsImage, error) {
	incOpCounter("insert")

	var out_out *C.VipsImage

	var cOpts C.GenInsertOpts
	var pinner runtime.Pinner
	defer pinner.Unpin()
	if opts != nil {
		if opts.Expand != nil {
			cOpts.has_expand = 1
			cOpts.expand = C.int(boolToInt(*opts.Expand))
		}
		if opts.Background != nil {
			cOpts.has_background = 1
			pinner.Pin(&opts.Background[0])
			cOpts.background = (*C.double)(unsafe.Pointer(&opts.Background[0]))
			cOpts.background_n = C.int(len(opts.Background))
		}
	}

	ret := C.gen_vips_insert(main, sub, C.int(x), C.int(y), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// JoinOptions are optional parameters for join.
type JoinOptions struct {
	Expand *bool
	Shim *int
	Background []float64
	Align *Align
}

// vipsGenJoin calls the vips join operation.
// join a pair of images
func vipsGenJoin(in1 *C.VipsImage, in2 *C.VipsImage, direction Direction, opts *JoinOptions) (*C.VipsImage, error) {
	incOpCounter("join")

	var out_out *C.VipsImage

	var cOpts C.GenJoinOpts
	var pinner runtime.Pinner
	defer pinner.Unpin()
	if opts != nil {
		if opts.Expand != nil {
			cOpts.has_expand = 1
			cOpts.expand = C.int(boolToInt(*opts.Expand))
		}
		if opts.Shim != nil {
			cOpts.has_shim = 1
			cOpts.shim = C.int(*opts.Shim)
		}
		if opts.Background != nil {
			cOpts.has_background = 1
			pinner.Pin(&opts.Background[0])
			cOpts.background = (*C.double)(unsafe.Pointer(&opts.Background[0]))
			cOpts.background_n = C.int(len(opts.Background))
		}
		if opts.Align != nil {
			cOpts.has_align = 1
			cOpts.align = C.VipsAlign(*opts.Align)
		}
	}

	ret := C.gen_vips_join(in1, in2, C.VipsDirection(direction), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// LinecacheOptions are optional parameters for linecache.
type LinecacheOptions struct {
	TileHeight *int
	Access *int
	Threaded *bool
	Persistent *bool
}

// vipsGenLinecache calls the vips linecache operation.
// cache an image as a set of lines
func vipsGenLinecache(input *C.VipsImage, opts *LinecacheOptions) (*C.VipsImage, error) {
	incOpCounter("linecache")

	var out_out *C.VipsImage

	var cOpts C.GenLinecacheOpts
	if opts != nil {
		if opts.TileHeight != nil {
			cOpts.has_tileHeight = 1
			cOpts.tileHeight = C.int(*opts.TileHeight)
		}
		if opts.Access != nil {
			cOpts.has_access = 1
			cOpts.access = C.VipsAccess(*opts.Access)
		}
		if opts.Threaded != nil {
			cOpts.has_threaded = 1
			cOpts.threaded = C.int(boolToInt(*opts.Threaded))
		}
		if opts.Persistent != nil {
			cOpts.has_persistent = 1
			cOpts.persistent = C.int(boolToInt(*opts.Persistent))
		}
	}

	ret := C.gen_vips_linecache(input, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// MsbOptions are optional parameters for msb.
type MsbOptions struct {
	Band *int
}

// vipsGenMsb calls the vips msb operation.
// pick most-significant byte from an image
func vipsGenMsb(input *C.VipsImage, opts *MsbOptions) (*C.VipsImage, error) {
	incOpCounter("msb")

	var out_out *C.VipsImage

	var cOpts C.GenMsbOpts
	if opts != nil {
		if opts.Band != nil {
			cOpts.has_band = 1
			cOpts.band = C.int(*opts.Band)
		}
	}

	ret := C.gen_vips_msb(input, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// PremultiplyOptions are optional parameters for premultiply.
type PremultiplyOptions struct {
	MaxAlpha *float64
}

// vipsGenPremultiply calls the vips premultiply operation.
// premultiply image alpha
func vipsGenPremultiply(input *C.VipsImage, opts *PremultiplyOptions) (*C.VipsImage, error) {
	incOpCounter("premultiply")

	var out_out *C.VipsImage

	var cOpts C.GenPremultiplyOpts
	if opts != nil {
		if opts.MaxAlpha != nil {
			cOpts.has_maxAlpha = 1
			cOpts.maxAlpha = C.double(*opts.MaxAlpha)
		}
	}

	ret := C.gen_vips_premultiply(input, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenRecomb calls the vips recomb operation.
// linear recombination with matrix
func vipsGenRecomb(input *C.VipsImage, m *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("recomb")

	var out_out *C.VipsImage

	ret := C.gen_vips_recomb(input, m, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenReplicate calls the vips replicate operation.
// replicate an image
func vipsGenReplicate(input *C.VipsImage, across int, down int) (*C.VipsImage, error) {
	incOpCounter("replicate")

	var out_out *C.VipsImage

	ret := C.gen_vips_replicate(input, C.int(across), C.int(down), &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenRot calls the vips rot operation.
// rotate an image
func vipsGenRot(input *C.VipsImage, angle Angle) (*C.VipsImage, error) {
	incOpCounter("rot")

	var out_out *C.VipsImage

	ret := C.gen_vips_rot(input, C.VipsAngle(angle), &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// Rot45Options are optional parameters for rot45.
type Rot45Options struct {
	Angle *Angle45
}

// vipsGenRot45 calls the vips rot45 operation.
// rotate an image
func vipsGenRot45(input *C.VipsImage, opts *Rot45Options) (*C.VipsImage, error) {
	incOpCounter("rot45")

	var out_out *C.VipsImage

	var cOpts C.GenRot45Opts
	if opts != nil {
		if opts.Angle != nil {
			cOpts.has_angle = 1
			cOpts.angle = C.VipsAngle45(*opts.Angle)
		}
	}

	ret := C.gen_vips_rot45(input, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// ScaleOptions are optional parameters for scale.
type ScaleOptions struct {
	Exp *float64
	Log *bool
}

// vipsGenScale calls the vips scale operation.
// scale an image to uchar
func vipsGenScale(input *C.VipsImage, opts *ScaleOptions) (*C.VipsImage, error) {
	incOpCounter("scale")

	var out_out *C.VipsImage

	var cOpts C.GenScaleOpts
	if opts != nil {
		if opts.Exp != nil {
			cOpts.has_exp = 1
			cOpts.exp = C.double(*opts.Exp)
		}
		if opts.Log != nil {
			cOpts.has_log = 1
			cOpts.log = C.int(boolToInt(*opts.Log))
		}
	}

	ret := C.gen_vips_scale(input, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// SequentialOptions are optional parameters for sequential.
type SequentialOptions struct {
	TileHeight *int
}

// vipsGenSequential calls the vips sequential operation.
// check sequential access
func vipsGenSequential(input *C.VipsImage, opts *SequentialOptions) (*C.VipsImage, error) {
	incOpCounter("sequential")

	var out_out *C.VipsImage

	var cOpts C.GenSequentialOpts
	if opts != nil {
		if opts.TileHeight != nil {
			cOpts.has_tileHeight = 1
			cOpts.tileHeight = C.int(*opts.TileHeight)
		}
	}

	ret := C.gen_vips_sequential(input, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// SmartcropOptions are optional parameters for smartcrop.
type SmartcropOptions struct {
	Interesting *Interesting
	Premultiplied *bool
}

// vipsGenSmartcrop calls the vips smartcrop operation.
// extract an area from an image
func vipsGenSmartcrop(input *C.VipsImage, width int, height int, opts *SmartcropOptions) (int, *C.VipsImage, int, error) {
	incOpCounter("smartcrop")

	var out_attentionX C.int
	var out_out *C.VipsImage
	var out_attentionY C.int

	var cOpts C.GenSmartcropOpts
	if opts != nil {
		if opts.Interesting != nil {
			cOpts.has_interesting = 1
			cOpts.interesting = C.VipsInteresting(*opts.Interesting)
		}
		if opts.Premultiplied != nil {
			cOpts.has_premultiplied = 1
			cOpts.premultiplied = C.int(boolToInt(*opts.Premultiplied))
		}
	}

	ret := C.gen_vips_smartcrop(input, C.int(width), C.int(height), &out_attentionX, &out_out, &out_attentionY, &cOpts)
	if ret != 0 {
		return 0, nil, 0, handleImageError(out_out)
	}

	return int(out_attentionX), out_out, int(out_attentionY), nil
}

// SubsampleOptions are optional parameters for subsample.
type SubsampleOptions struct {
	Point *bool
}

// vipsGenSubsample calls the vips subsample operation.
// subsample an image
func vipsGenSubsample(input *C.VipsImage, xfac int, yfac int, opts *SubsampleOptions) (*C.VipsImage, error) {
	incOpCounter("subsample")

	var out_out *C.VipsImage

	var cOpts C.GenSubsampleOpts
	if opts != nil {
		if opts.Point != nil {
			cOpts.has_point = 1
			cOpts.point = C.int(boolToInt(*opts.Point))
		}
	}

	ret := C.gen_vips_subsample(input, C.int(xfac), C.int(yfac), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// TilecacheOptions are optional parameters for tilecache.
type TilecacheOptions struct {
	TileWidth *int
	TileHeight *int
	MaxTiles *int
	Access *int
	Threaded *bool
	Persistent *bool
}

// vipsGenTilecache calls the vips tilecache operation.
// cache an image as a set of tiles
func vipsGenTilecache(input *C.VipsImage, opts *TilecacheOptions) (*C.VipsImage, error) {
	incOpCounter("tilecache")

	var out_out *C.VipsImage

	var cOpts C.GenTilecacheOpts
	if opts != nil {
		if opts.TileWidth != nil {
			cOpts.has_tileWidth = 1
			cOpts.tileWidth = C.int(*opts.TileWidth)
		}
		if opts.TileHeight != nil {
			cOpts.has_tileHeight = 1
			cOpts.tileHeight = C.int(*opts.TileHeight)
		}
		if opts.MaxTiles != nil {
			cOpts.has_maxTiles = 1
			cOpts.maxTiles = C.int(*opts.MaxTiles)
		}
		if opts.Access != nil {
			cOpts.has_access = 1
			cOpts.access = C.VipsAccess(*opts.Access)
		}
		if opts.Threaded != nil {
			cOpts.has_threaded = 1
			cOpts.threaded = C.int(boolToInt(*opts.Threaded))
		}
		if opts.Persistent != nil {
			cOpts.has_persistent = 1
			cOpts.persistent = C.int(boolToInt(*opts.Persistent))
		}
	}

	ret := C.gen_vips_tilecache(input, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// Transpose3dOptions are optional parameters for transpose3d.
type Transpose3dOptions struct {
	PageHeight *int
}

// vipsGenTranspose3d calls the vips transpose3d operation.
// transpose3d an image
func vipsGenTranspose3d(input *C.VipsImage, opts *Transpose3dOptions) (*C.VipsImage, error) {
	incOpCounter("transpose3d")

	var out_out *C.VipsImage

	var cOpts C.GenTranspose3dOpts
	if opts != nil {
		if opts.PageHeight != nil {
			cOpts.has_pageHeight = 1
			cOpts.pageHeight = C.int(*opts.PageHeight)
		}
	}

	ret := C.gen_vips_transpose3d(input, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// UnpremultiplyOptions are optional parameters for unpremultiply.
type UnpremultiplyOptions struct {
	MaxAlpha *float64
	AlphaBand *int
}

// vipsGenUnpremultiply calls the vips unpremultiply operation.
// unpremultiply image alpha
func vipsGenUnpremultiply(input *C.VipsImage, opts *UnpremultiplyOptions) (*C.VipsImage, error) {
	incOpCounter("unpremultiply")

	var out_out *C.VipsImage

	var cOpts C.GenUnpremultiplyOpts
	if opts != nil {
		if opts.MaxAlpha != nil {
			cOpts.has_maxAlpha = 1
			cOpts.maxAlpha = C.double(*opts.MaxAlpha)
		}
		if opts.AlphaBand != nil {
			cOpts.has_alphaBand = 1
			cOpts.alphaBand = C.int(*opts.AlphaBand)
		}
	}

	ret := C.gen_vips_unpremultiply(input, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// WrapOptions are optional parameters for wrap.
type WrapOptions struct {
	X *int
	Y *int
}

// vipsGenWrap calls the vips wrap operation.
// wrap image origin
func vipsGenWrap(input *C.VipsImage, opts *WrapOptions) (*C.VipsImage, error) {
	incOpCounter("wrap")

	var out_out *C.VipsImage

	var cOpts C.GenWrapOpts
	if opts != nil {
		if opts.X != nil {
			cOpts.has_x = 1
			cOpts.x = C.int(*opts.X)
		}
		if opts.Y != nil {
			cOpts.has_y = 1
			cOpts.y = C.int(*opts.Y)
		}
	}

	ret := C.gen_vips_wrap(input, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenZoom calls the vips zoom operation.
// zoom an image
func vipsGenZoom(input *C.VipsImage, xfac int, yfac int) (*C.VipsImage, error) {
	incOpCounter("zoom")

	var out_out *C.VipsImage

	ret := C.gen_vips_zoom(input, C.int(xfac), C.int(yfac), &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

