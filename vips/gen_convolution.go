// Code generated by vipsgen. DO NOT EDIT.
package vips

// #include "gen_convolution.h"
import "C"

import "unsafe"

// Ensure imports are used.
var _ = unsafe.Pointer(nil)

// CannyOptions are optional parameters for canny.
type CannyOptions struct {
	Sigma *float64
	Precision *Precision
}

// vipsGenCanny calls the vips canny operation.
// Canny edge detector
func vipsGenCanny(input *C.VipsImage, opts *CannyOptions) (*C.VipsImage, error) {
	incOpCounter("canny")

	var out_out *C.VipsImage

	var cOpts C.GenCannyOpts
	if opts != nil {
		if opts.Sigma != nil {
			cOpts.has_sigma = 1
			cOpts.sigma = C.double(*opts.Sigma)
		}
		if opts.Precision != nil {
			cOpts.has_precision = 1
			cOpts.precision = C.VipsPrecision(*opts.Precision)
		}
	}

	ret := C.gen_vips_canny(input, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// CompassOptions are optional parameters for compass.
type CompassOptions struct {
	Times *int
	Angle *Angle45
	Combine *Combine
	Precision *Precision
	Layers *int
	Cluster *int
}

// vipsGenCompass calls the vips compass operation.
// convolve with rotating mask
func vipsGenCompass(input *C.VipsImage, mask *C.VipsImage, opts *CompassOptions) (*C.VipsImage, error) {
	incOpCounter("compass")

	var out_out *C.VipsImage

	var cOpts C.GenCompassOpts
	if opts != nil {
		if opts.Times != nil {
			cOpts.has_times = 1
			cOpts.times = C.int(*opts.Times)
		}
		if opts.Angle != nil {
			cOpts.has_angle = 1
			cOpts.angle = C.VipsAngle45(*opts.Angle)
		}
		if opts.Combine != nil {
			cOpts.has_combine = 1
			cOpts.combine = C.VipsCombine(*opts.Combine)
		}
		if opts.Precision != nil {
			cOpts.has_precision = 1
			cOpts.precision = C.VipsPrecision(*opts.Precision)
		}
		if opts.Layers != nil {
			cOpts.has_layers = 1
			cOpts.layers = C.int(*opts.Layers)
		}
		if opts.Cluster != nil {
			cOpts.has_cluster = 1
			cOpts.cluster = C.int(*opts.Cluster)
		}
	}

	ret := C.gen_vips_compass(input, mask, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// ConvOptions are optional parameters for conv.
type ConvOptions struct {
	Precision *Precision
	Layers *int
	Cluster *int
}

// vipsGenConv calls the vips conv operation.
// convolution operation
func vipsGenConv(input *C.VipsImage, mask *C.VipsImage, opts *ConvOptions) (*C.VipsImage, error) {
	incOpCounter("conv")

	var out_out *C.VipsImage

	var cOpts C.GenConvOpts
	if opts != nil {
		if opts.Precision != nil {
			cOpts.has_precision = 1
			cOpts.precision = C.VipsPrecision(*opts.Precision)
		}
		if opts.Layers != nil {
			cOpts.has_layers = 1
			cOpts.layers = C.int(*opts.Layers)
		}
		if opts.Cluster != nil {
			cOpts.has_cluster = 1
			cOpts.cluster = C.int(*opts.Cluster)
		}
	}

	ret := C.gen_vips_conv(input, mask, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// ConvaOptions are optional parameters for conva.
type ConvaOptions struct {
	Layers *int
	Cluster *int
}

// vipsGenConva calls the vips conva operation.
// approximate integer convolution
func vipsGenConva(input *C.VipsImage, mask *C.VipsImage, opts *ConvaOptions) (*C.VipsImage, error) {
	incOpCounter("conva")

	var out_out *C.VipsImage

	var cOpts C.GenConvaOpts
	if opts != nil {
		if opts.Layers != nil {
			cOpts.has_layers = 1
			cOpts.layers = C.int(*opts.Layers)
		}
		if opts.Cluster != nil {
			cOpts.has_cluster = 1
			cOpts.cluster = C.int(*opts.Cluster)
		}
	}

	ret := C.gen_vips_conva(input, mask, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// ConvasepOptions are optional parameters for convasep.
type ConvasepOptions struct {
	Layers *int
}

// vipsGenConvasep calls the vips convasep operation.
// approximate separable integer convolution
func vipsGenConvasep(input *C.VipsImage, mask *C.VipsImage, opts *ConvasepOptions) (*C.VipsImage, error) {
	incOpCounter("convasep")

	var out_out *C.VipsImage

	var cOpts C.GenConvasepOpts
	if opts != nil {
		if opts.Layers != nil {
			cOpts.has_layers = 1
			cOpts.layers = C.int(*opts.Layers)
		}
	}

	ret := C.gen_vips_convasep(input, mask, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenConvf calls the vips convf operation.
// float convolution operation
func vipsGenConvf(input *C.VipsImage, mask *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("convf")

	var out_out *C.VipsImage

	ret := C.gen_vips_convf(input, mask, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenConvi calls the vips convi operation.
// int convolution operation
func vipsGenConvi(input *C.VipsImage, mask *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("convi")

	var out_out *C.VipsImage

	ret := C.gen_vips_convi(input, mask, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// ConvsepOptions are optional parameters for convsep.
type ConvsepOptions struct {
	Precision *Precision
	Layers *int
	Cluster *int
}

// vipsGenConvsep calls the vips convsep operation.
// separable convolution operation
func vipsGenConvsep(input *C.VipsImage, mask *C.VipsImage, opts *ConvsepOptions) (*C.VipsImage, error) {
	incOpCounter("convsep")

	var out_out *C.VipsImage

	var cOpts C.GenConvsepOpts
	if opts != nil {
		if opts.Precision != nil {
			cOpts.has_precision = 1
			cOpts.precision = C.VipsPrecision(*opts.Precision)
		}
		if opts.Layers != nil {
			cOpts.has_layers = 1
			cOpts.layers = C.int(*opts.Layers)
		}
		if opts.Cluster != nil {
			cOpts.has_cluster = 1
			cOpts.cluster = C.int(*opts.Cluster)
		}
	}

	ret := C.gen_vips_convsep(input, mask, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenFastcor calls the vips fastcor operation.
// fast correlation
func vipsGenFastcor(input *C.VipsImage, ref *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("fastcor")

	var out_out *C.VipsImage

	ret := C.gen_vips_fastcor(input, ref, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// GaussblurOptions are optional parameters for gaussblur.
type GaussblurOptions struct {
	MinAmpl *float64
	Precision *Precision
}

// vipsGenGaussblur calls the vips gaussblur operation.
// gaussian blur
func vipsGenGaussblur(input *C.VipsImage, sigma float64, opts *GaussblurOptions) (*C.VipsImage, error) {
	incOpCounter("gaussblur")

	var out_out *C.VipsImage

	var cOpts C.GenGaussblurOpts
	if opts != nil {
		if opts.MinAmpl != nil {
			cOpts.has_minAmpl = 1
			cOpts.minAmpl = C.double(*opts.MinAmpl)
		}
		if opts.Precision != nil {
			cOpts.has_precision = 1
			cOpts.precision = C.VipsPrecision(*opts.Precision)
		}
	}

	ret := C.gen_vips_gaussblur(input, C.double(sigma), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenPrewitt calls the vips prewitt operation.
// Prewitt edge detector
func vipsGenPrewitt(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("prewitt")

	var out_out *C.VipsImage

	ret := C.gen_vips_prewitt(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenScharr calls the vips scharr operation.
// Scharr edge detector
func vipsGenScharr(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("scharr")

	var out_out *C.VipsImage

	ret := C.gen_vips_scharr(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// SharpenOptions are optional parameters for sharpen.
type SharpenOptions struct {
	Sigma *float64
	X1 *float64
	Y2 *float64
	Y3 *float64
	M1 *float64
	M2 *float64
}

// vipsGenSharpen calls the vips sharpen operation.
// unsharp masking for print
func vipsGenSharpen(input *C.VipsImage, opts *SharpenOptions) (*C.VipsImage, error) {
	incOpCounter("sharpen")

	var out_out *C.VipsImage

	var cOpts C.GenSharpenOpts
	if opts != nil {
		if opts.Sigma != nil {
			cOpts.has_sigma = 1
			cOpts.sigma = C.double(*opts.Sigma)
		}
		if opts.X1 != nil {
			cOpts.has_x1 = 1
			cOpts.x1 = C.double(*opts.X1)
		}
		if opts.Y2 != nil {
			cOpts.has_y2 = 1
			cOpts.y2 = C.double(*opts.Y2)
		}
		if opts.Y3 != nil {
			cOpts.has_y3 = 1
			cOpts.y3 = C.double(*opts.Y3)
		}
		if opts.M1 != nil {
			cOpts.has_m1 = 1
			cOpts.m1 = C.double(*opts.M1)
		}
		if opts.M2 != nil {
			cOpts.has_m2 = 1
			cOpts.m2 = C.double(*opts.M2)
		}
	}

	ret := C.gen_vips_sharpen(input, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenSobel calls the vips sobel operation.
// Sobel edge detector
func vipsGenSobel(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("sobel")

	var out_out *C.VipsImage

	ret := C.gen_vips_sobel(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenSpcor calls the vips spcor operation.
// spatial correlation
func vipsGenSpcor(input *C.VipsImage, ref *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("spcor")

	var out_out *C.VipsImage

	ret := C.gen_vips_spcor(input, ref, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

