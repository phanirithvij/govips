// Code generated by vipsgen. DO NOT EDIT.
package vips

// #include "gen_resample.h"
import "C"

import (
	"runtime"
	"unsafe"
)

// Ensure imports are used.
var _ = unsafe.Pointer(nil)

// AffineOptions are optional parameters for affine.
type AffineOptions struct {
	Interpolate *C.VipsInterpolate
	Oarea []int
	Odx *float64
	Ody *float64
	Idx *float64
	Idy *float64
	Background []float64
	Premultiplied *bool
	Extend *ExtendStrategy
}

// vipsGenAffine calls the vips affine operation.
// affine transform of an image
func vipsGenAffine(input *C.VipsImage, matrix []float64, opts *AffineOptions) (*C.VipsImage, error) {
	incOpCounter("affine")

	var out_out *C.VipsImage

	var cOpts C.GenAffineOpts
	var pinner runtime.Pinner
	defer pinner.Unpin()
	if opts != nil {
		if opts.Interpolate != nil {
			cOpts.has_interpolate = 1
			cOpts.interpolate = opts.Interpolate
		}
		if opts.Oarea != nil {
			cOpts.has_oarea = 1
			pinner.Pin(&opts.Oarea[0])
			cOpts.oarea = (*C.int)(unsafe.Pointer(&opts.Oarea[0]))
			cOpts.oarea_n = C.int(len(opts.Oarea))
		}
		if opts.Odx != nil {
			cOpts.has_odx = 1
			cOpts.odx = C.double(*opts.Odx)
		}
		if opts.Ody != nil {
			cOpts.has_ody = 1
			cOpts.ody = C.double(*opts.Ody)
		}
		if opts.Idx != nil {
			cOpts.has_idx = 1
			cOpts.idx = C.double(*opts.Idx)
		}
		if opts.Idy != nil {
			cOpts.has_idy = 1
			cOpts.idy = C.double(*opts.Idy)
		}
		if opts.Background != nil {
			cOpts.has_background = 1
			pinner.Pin(&opts.Background[0])
			cOpts.background = (*C.double)(unsafe.Pointer(&opts.Background[0]))
			cOpts.background_n = C.int(len(opts.Background))
		}
		if opts.Premultiplied != nil {
			cOpts.has_premultiplied = 1
			cOpts.premultiplied = C.int(boolToInt(*opts.Premultiplied))
		}
		if opts.Extend != nil {
			cOpts.has_extend = 1
			cOpts.extend = C.VipsExtend(*opts.Extend)
		}
	}

	ret := C.gen_vips_affine(input, (*C.double)(unsafe.Pointer(&matrix[0])), C.int(len(matrix)), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// GlobalbalanceOptions are optional parameters for globalbalance.
type GlobalbalanceOptions struct {
	Gamma *float64
	IntOutput *bool
}

// vipsGenGlobalbalance calls the vips globalbalance operation.
// global balance an image mosaic
func vipsGenGlobalbalance(input *C.VipsImage, opts *GlobalbalanceOptions) (*C.VipsImage, error) {
	incOpCounter("globalbalance")

	var out_out *C.VipsImage

	var cOpts C.GenGlobalbalanceOpts
	if opts != nil {
		if opts.Gamma != nil {
			cOpts.has_gamma = 1
			cOpts.gamma = C.double(*opts.Gamma)
		}
		if opts.IntOutput != nil {
			cOpts.has_intOutput = 1
			cOpts.intOutput = C.int(boolToInt(*opts.IntOutput))
		}
	}

	ret := C.gen_vips_globalbalance(input, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// MapimOptions are optional parameters for mapim.
type MapimOptions struct {
	Interpolate *C.VipsInterpolate
	Background []float64
	Premultiplied *bool
	Extend *ExtendStrategy
}

// vipsGenMapim calls the vips mapim operation.
// resample with a map image
func vipsGenMapim(input *C.VipsImage, index *C.VipsImage, opts *MapimOptions) (*C.VipsImage, error) {
	incOpCounter("mapim")

	var out_out *C.VipsImage

	var cOpts C.GenMapimOpts
	var pinner runtime.Pinner
	defer pinner.Unpin()
	if opts != nil {
		if opts.Interpolate != nil {
			cOpts.has_interpolate = 1
			cOpts.interpolate = opts.Interpolate
		}
		if opts.Background != nil {
			cOpts.has_background = 1
			pinner.Pin(&opts.Background[0])
			cOpts.background = (*C.double)(unsafe.Pointer(&opts.Background[0]))
			cOpts.background_n = C.int(len(opts.Background))
		}
		if opts.Premultiplied != nil {
			cOpts.has_premultiplied = 1
			cOpts.premultiplied = C.int(boolToInt(*opts.Premultiplied))
		}
		if opts.Extend != nil {
			cOpts.has_extend = 1
			cOpts.extend = C.VipsExtend(*opts.Extend)
		}
	}

	ret := C.gen_vips_mapim(input, index, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// MatchOptions are optional parameters for match.
type MatchOptions struct {
	Hwindow *int
	Harea *int
	Search *bool
	Interpolate *C.VipsInterpolate
}

// vipsGenMatch calls the vips match operation.
// first-order match of two images
func vipsGenMatch(ref *C.VipsImage, sec *C.VipsImage, xr1 int, yr1 int, xs1 int, ys1 int, xr2 int, yr2 int, xs2 int, ys2 int, opts *MatchOptions) (*C.VipsImage, error) {
	incOpCounter("match")

	var out_out *C.VipsImage

	var cOpts C.GenMatchOpts
	if opts != nil {
		if opts.Hwindow != nil {
			cOpts.has_hwindow = 1
			cOpts.hwindow = C.int(*opts.Hwindow)
		}
		if opts.Harea != nil {
			cOpts.has_harea = 1
			cOpts.harea = C.int(*opts.Harea)
		}
		if opts.Search != nil {
			cOpts.has_search = 1
			cOpts.search = C.int(boolToInt(*opts.Search))
		}
		if opts.Interpolate != nil {
			cOpts.has_interpolate = 1
			cOpts.interpolate = opts.Interpolate
		}
	}

	ret := C.gen_vips_match(ref, sec, C.int(xr1), C.int(yr1), C.int(xs1), C.int(ys1), C.int(xr2), C.int(yr2), C.int(xs2), C.int(ys2), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// MergeOptions are optional parameters for merge.
type MergeOptions struct {
	Mblend *int
}

// vipsGenMerge calls the vips merge operation.
// merge two images
func vipsGenMerge(ref *C.VipsImage, sec *C.VipsImage, direction Direction, dx int, dy int, opts *MergeOptions) (*C.VipsImage, error) {
	incOpCounter("merge")

	var out_out *C.VipsImage

	var cOpts C.GenMergeOpts
	if opts != nil {
		if opts.Mblend != nil {
			cOpts.has_mblend = 1
			cOpts.mblend = C.int(*opts.Mblend)
		}
	}

	ret := C.gen_vips_merge(ref, sec, C.VipsDirection(direction), C.int(dx), C.int(dy), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// MosaicOptions are optional parameters for mosaic.
type MosaicOptions struct {
	Hwindow *int
	Harea *int
	Mblend *int
	Bandno *int
}

// vipsGenMosaic calls the vips mosaic operation.
// mosaic two images
func vipsGenMosaic(ref *C.VipsImage, sec *C.VipsImage, direction Direction, xref int, yref int, xsec int, ysec int, opts *MosaicOptions) (*C.VipsImage, int, int, float64, float64, float64, float64, error) {
	incOpCounter("mosaic")

	var out_out *C.VipsImage
	var out_dx0 C.int
	var out_dy0 C.int
	var out_scale1 C.double
	var out_angle1 C.double
	var out_dy1 C.double
	var out_dx1 C.double

	var cOpts C.GenMosaicOpts
	if opts != nil {
		if opts.Hwindow != nil {
			cOpts.has_hwindow = 1
			cOpts.hwindow = C.int(*opts.Hwindow)
		}
		if opts.Harea != nil {
			cOpts.has_harea = 1
			cOpts.harea = C.int(*opts.Harea)
		}
		if opts.Mblend != nil {
			cOpts.has_mblend = 1
			cOpts.mblend = C.int(*opts.Mblend)
		}
		if opts.Bandno != nil {
			cOpts.has_bandno = 1
			cOpts.bandno = C.int(*opts.Bandno)
		}
	}

	ret := C.gen_vips_mosaic(ref, sec, C.VipsDirection(direction), C.int(xref), C.int(yref), C.int(xsec), C.int(ysec), &out_out, &out_dx0, &out_dy0, &out_scale1, &out_angle1, &out_dy1, &out_dx1, &cOpts)
	if ret != 0 {
		return nil, 0, 0, 0, 0, 0, 0, handleImageError(out_out)
	}

	return out_out, int(out_dx0), int(out_dy0), float64(out_scale1), float64(out_angle1), float64(out_dy1), float64(out_dx1), nil
}

// Mosaic1Options are optional parameters for mosaic1.
type Mosaic1Options struct {
	Hwindow *int
	Harea *int
	Search *bool
	Interpolate *C.VipsInterpolate
	Mblend *int
}

// vipsGenMosaic1 calls the vips mosaic1 operation.
// first-order mosaic of two images
func vipsGenMosaic1(ref *C.VipsImage, sec *C.VipsImage, direction Direction, xr1 int, yr1 int, xs1 int, ys1 int, xr2 int, yr2 int, xs2 int, ys2 int, opts *Mosaic1Options) (*C.VipsImage, error) {
	incOpCounter("mosaic1")

	var out_out *C.VipsImage

	var cOpts C.GenMosaic1Opts
	if opts != nil {
		if opts.Hwindow != nil {
			cOpts.has_hwindow = 1
			cOpts.hwindow = C.int(*opts.Hwindow)
		}
		if opts.Harea != nil {
			cOpts.has_harea = 1
			cOpts.harea = C.int(*opts.Harea)
		}
		if opts.Search != nil {
			cOpts.has_search = 1
			cOpts.search = C.int(boolToInt(*opts.Search))
		}
		if opts.Interpolate != nil {
			cOpts.has_interpolate = 1
			cOpts.interpolate = opts.Interpolate
		}
		if opts.Mblend != nil {
			cOpts.has_mblend = 1
			cOpts.mblend = C.int(*opts.Mblend)
		}
	}

	ret := C.gen_vips_mosaic1(ref, sec, C.VipsDirection(direction), C.int(xr1), C.int(yr1), C.int(xs1), C.int(ys1), C.int(xr2), C.int(yr2), C.int(xs2), C.int(ys2), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// QuadraticOptions are optional parameters for quadratic.
type QuadraticOptions struct {
	Interpolate *C.VipsInterpolate
}

// vipsGenQuadratic calls the vips quadratic operation.
// resample an image with a quadratic transform
func vipsGenQuadratic(input *C.VipsImage, coeff *C.VipsImage, opts *QuadraticOptions) (*C.VipsImage, error) {
	incOpCounter("quadratic")

	var out_out *C.VipsImage

	var cOpts C.GenQuadraticOpts
	if opts != nil {
		if opts.Interpolate != nil {
			cOpts.has_interpolate = 1
			cOpts.interpolate = opts.Interpolate
		}
	}

	ret := C.gen_vips_quadratic(input, coeff, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// ReduceOptions are optional parameters for reduce.
type ReduceOptions struct {
	Kernel *Kernel
	Gap *float64
}

// vipsGenReduce calls the vips reduce operation.
// reduce an image
func vipsGenReduce(input *C.VipsImage, hshrink float64, vshrink float64, opts *ReduceOptions) (*C.VipsImage, error) {
	incOpCounter("reduce")

	var out_out *C.VipsImage

	var cOpts C.GenReduceOpts
	if opts != nil {
		if opts.Kernel != nil {
			cOpts.has_kernel = 1
			cOpts.kernel = C.VipsKernel(*opts.Kernel)
		}
		if opts.Gap != nil {
			cOpts.has_gap = 1
			cOpts.gap = C.double(*opts.Gap)
		}
	}

	ret := C.gen_vips_reduce(input, C.double(hshrink), C.double(vshrink), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// ReducehOptions are optional parameters for reduceh.
type ReducehOptions struct {
	Kernel *Kernel
	Gap *float64
}

// vipsGenReduceh calls the vips reduceh operation.
// shrink an image horizontally
func vipsGenReduceh(input *C.VipsImage, hshrink float64, opts *ReducehOptions) (*C.VipsImage, error) {
	incOpCounter("reduceh")

	var out_out *C.VipsImage

	var cOpts C.GenReducehOpts
	if opts != nil {
		if opts.Kernel != nil {
			cOpts.has_kernel = 1
			cOpts.kernel = C.VipsKernel(*opts.Kernel)
		}
		if opts.Gap != nil {
			cOpts.has_gap = 1
			cOpts.gap = C.double(*opts.Gap)
		}
	}

	ret := C.gen_vips_reduceh(input, C.double(hshrink), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// ReducevOptions are optional parameters for reducev.
type ReducevOptions struct {
	Kernel *Kernel
	Gap *float64
}

// vipsGenReducev calls the vips reducev operation.
// shrink an image vertically
func vipsGenReducev(input *C.VipsImage, vshrink float64, opts *ReducevOptions) (*C.VipsImage, error) {
	incOpCounter("reducev")

	var out_out *C.VipsImage

	var cOpts C.GenReducevOpts
	if opts != nil {
		if opts.Kernel != nil {
			cOpts.has_kernel = 1
			cOpts.kernel = C.VipsKernel(*opts.Kernel)
		}
		if opts.Gap != nil {
			cOpts.has_gap = 1
			cOpts.gap = C.double(*opts.Gap)
		}
	}

	ret := C.gen_vips_reducev(input, C.double(vshrink), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenRemosaic calls the vips remosaic operation.
// rebuild an mosaiced image
func vipsGenRemosaic(input *C.VipsImage, oldStr string, newStr string) (*C.VipsImage, error) {
	incOpCounter("remosaic")

	cStr_oldStr := C.CString(oldStr)
	defer C.free(unsafe.Pointer(cStr_oldStr))
	cStr_newStr := C.CString(newStr)
	defer C.free(unsafe.Pointer(cStr_newStr))
	var out_out *C.VipsImage

	ret := C.gen_vips_remosaic(input, cStr_oldStr, cStr_newStr, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// RotateOptions are optional parameters for rotate.
type RotateOptions struct {
	Interpolate *C.VipsInterpolate
	Background []float64
	Odx *float64
	Ody *float64
	Idx *float64
	Idy *float64
}

// vipsGenRotate calls the vips rotate operation.
// rotate an image by a number of degrees
func vipsGenRotate(input *C.VipsImage, angle float64, opts *RotateOptions) (*C.VipsImage, error) {
	incOpCounter("rotate")

	var out_out *C.VipsImage

	var cOpts C.GenRotateOpts
	var pinner runtime.Pinner
	defer pinner.Unpin()
	if opts != nil {
		if opts.Interpolate != nil {
			cOpts.has_interpolate = 1
			cOpts.interpolate = opts.Interpolate
		}
		if opts.Background != nil {
			cOpts.has_background = 1
			pinner.Pin(&opts.Background[0])
			cOpts.background = (*C.double)(unsafe.Pointer(&opts.Background[0]))
			cOpts.background_n = C.int(len(opts.Background))
		}
		if opts.Odx != nil {
			cOpts.has_odx = 1
			cOpts.odx = C.double(*opts.Odx)
		}
		if opts.Ody != nil {
			cOpts.has_ody = 1
			cOpts.ody = C.double(*opts.Ody)
		}
		if opts.Idx != nil {
			cOpts.has_idx = 1
			cOpts.idx = C.double(*opts.Idx)
		}
		if opts.Idy != nil {
			cOpts.has_idy = 1
			cOpts.idy = C.double(*opts.Idy)
		}
	}

	ret := C.gen_vips_rotate(input, C.double(angle), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// ShrinkOptions are optional parameters for shrink.
type ShrinkOptions struct {
	Ceil *bool
}

// vipsGenShrink calls the vips shrink operation.
// shrink an image
func vipsGenShrink(input *C.VipsImage, hshrink float64, vshrink float64, opts *ShrinkOptions) (*C.VipsImage, error) {
	incOpCounter("shrink")

	var out_out *C.VipsImage

	var cOpts C.GenShrinkOpts
	if opts != nil {
		if opts.Ceil != nil {
			cOpts.has_ceil = 1
			cOpts.ceil = C.int(boolToInt(*opts.Ceil))
		}
	}

	ret := C.gen_vips_shrink(input, C.double(hshrink), C.double(vshrink), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// ShrinkhOptions are optional parameters for shrinkh.
type ShrinkhOptions struct {
	Ceil *bool
}

// vipsGenShrinkh calls the vips shrinkh operation.
// shrink an image horizontally
func vipsGenShrinkh(input *C.VipsImage, hshrink int, opts *ShrinkhOptions) (*C.VipsImage, error) {
	incOpCounter("shrinkh")

	var out_out *C.VipsImage

	var cOpts C.GenShrinkhOpts
	if opts != nil {
		if opts.Ceil != nil {
			cOpts.has_ceil = 1
			cOpts.ceil = C.int(boolToInt(*opts.Ceil))
		}
	}

	ret := C.gen_vips_shrinkh(input, C.int(hshrink), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// ShrinkvOptions are optional parameters for shrinkv.
type ShrinkvOptions struct {
	Ceil *bool
}

// vipsGenShrinkv calls the vips shrinkv operation.
// shrink an image vertically
func vipsGenShrinkv(input *C.VipsImage, vshrink int, opts *ShrinkvOptions) (*C.VipsImage, error) {
	incOpCounter("shrinkv")

	var out_out *C.VipsImage

	var cOpts C.GenShrinkvOpts
	if opts != nil {
		if opts.Ceil != nil {
			cOpts.has_ceil = 1
			cOpts.ceil = C.int(boolToInt(*opts.Ceil))
		}
	}

	ret := C.gen_vips_shrinkv(input, C.int(vshrink), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// SimilarityOptions are optional parameters for similarity.
type SimilarityOptions struct {
	Scale *float64
	Angle *float64
	Interpolate *C.VipsInterpolate
	Background []float64
	Odx *float64
	Ody *float64
	Idx *float64
	Idy *float64
}

// vipsGenSimilarity calls the vips similarity operation.
// similarity transform of an image
func vipsGenSimilarity(input *C.VipsImage, opts *SimilarityOptions) (*C.VipsImage, error) {
	incOpCounter("similarity")

	var out_out *C.VipsImage

	var cOpts C.GenSimilarityOpts
	var pinner runtime.Pinner
	defer pinner.Unpin()
	if opts != nil {
		if opts.Scale != nil {
			cOpts.has_scale = 1
			cOpts.scale = C.double(*opts.Scale)
		}
		if opts.Angle != nil {
			cOpts.has_angle = 1
			cOpts.angle = C.double(*opts.Angle)
		}
		if opts.Interpolate != nil {
			cOpts.has_interpolate = 1
			cOpts.interpolate = opts.Interpolate
		}
		if opts.Background != nil {
			cOpts.has_background = 1
			pinner.Pin(&opts.Background[0])
			cOpts.background = (*C.double)(unsafe.Pointer(&opts.Background[0]))
			cOpts.background_n = C.int(len(opts.Background))
		}
		if opts.Odx != nil {
			cOpts.has_odx = 1
			cOpts.odx = C.double(*opts.Odx)
		}
		if opts.Ody != nil {
			cOpts.has_ody = 1
			cOpts.ody = C.double(*opts.Ody)
		}
		if opts.Idx != nil {
			cOpts.has_idx = 1
			cOpts.idx = C.double(*opts.Idx)
		}
		if opts.Idy != nil {
			cOpts.has_idy = 1
			cOpts.idy = C.double(*opts.Idy)
		}
	}

	ret := C.gen_vips_similarity(input, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

