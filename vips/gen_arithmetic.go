// Code generated by vipsgen. DO NOT EDIT.
package vips

// #include "gen_arithmetic.h"
import "C"

import "unsafe"

// Ensure imports are used.
var _ = unsafe.Pointer(nil)

// vipsGenAbs calls the vips abs operation.
// absolute value of an image
func vipsGenAbs(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("abs")

	var out_out *C.VipsImage

	ret := C.gen_vips_abs(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenAdd calls the vips add operation.
// add two images
func vipsGenAdd(left *C.VipsImage, right *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("add")

	var out_out *C.VipsImage

	ret := C.gen_vips_add(left, right, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenAvg calls the vips avg operation.
// find image average
func vipsGenAvg(input *C.VipsImage) (float64, error) {
	incOpCounter("avg")

	var out_out C.double

	ret := C.gen_vips_avg(input, &out_out)
	if ret != 0 {
		return 0, handleVipsError()
	}

	return float64(out_out), nil
}

// vipsGenBoolean calls the vips boolean operation.
// boolean operation on two images
func vipsGenBoolean(left *C.VipsImage, right *C.VipsImage, boolean OperationBoolean) (*C.VipsImage, error) {
	incOpCounter("boolean")

	var out_out *C.VipsImage

	ret := C.gen_vips_boolean(left, right, C.VipsOperationBoolean(boolean), &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenBooleanConst calls the vips boolean_const operation.
// boolean operations against a constant
func vipsGenBooleanConst(input *C.VipsImage, boolean OperationBoolean, c []float64) (*C.VipsImage, error) {
	incOpCounter("boolean_const")

	var out_out *C.VipsImage

	ret := C.gen_vips_boolean_const(input, C.VipsOperationBoolean(boolean), (*C.double)(unsafe.Pointer(&c[0])), C.int(len(c)), &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// ClampOptions are optional parameters for clamp.
type ClampOptions struct {
	Min *float64
	Max *float64
}

// vipsGenClamp calls the vips clamp operation.
// clamp values of an image
func vipsGenClamp(input *C.VipsImage, opts *ClampOptions) (*C.VipsImage, error) {
	incOpCounter("clamp")

	var out_out *C.VipsImage

	var cOpts C.GenClampOpts
	if opts != nil {
		if opts.Min != nil {
			cOpts.has_min = 1
			cOpts.min = C.double(*opts.Min)
		}
		if opts.Max != nil {
			cOpts.has_max = 1
			cOpts.max = C.double(*opts.Max)
		}
	}

	ret := C.gen_vips_clamp(input, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenComplex calls the vips complex operation.
// perform a complex operation on an image
func vipsGenComplex(input *C.VipsImage, cmplx OperationComplex) (*C.VipsImage, error) {
	incOpCounter("complex")

	var out_out *C.VipsImage

	ret := C.gen_vips_complex(input, C.VipsOperationComplex(cmplx), &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenComplex2 calls the vips complex2 operation.
// complex binary operations on two images
func vipsGenComplex2(left *C.VipsImage, right *C.VipsImage, cmplx OperationComplex2) (*C.VipsImage, error) {
	incOpCounter("complex2")

	var out_out *C.VipsImage

	ret := C.gen_vips_complex2(left, right, C.VipsOperationComplex2(cmplx), &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenComplexform calls the vips complexform operation.
// form a complex image from two real images
func vipsGenComplexform(left *C.VipsImage, right *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("complexform")

	var out_out *C.VipsImage

	ret := C.gen_vips_complexform(left, right, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenComplexget calls the vips complexget operation.
// get a component from a complex image
func vipsGenComplexget(input *C.VipsImage, get OperationComplexget) (*C.VipsImage, error) {
	incOpCounter("complexget")

	var out_out *C.VipsImage

	ret := C.gen_vips_complexget(input, C.VipsOperationComplexget(get), &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenDeviate calls the vips deviate operation.
// find image standard deviation
func vipsGenDeviate(input *C.VipsImage) (float64, error) {
	incOpCounter("deviate")

	var out_out C.double

	ret := C.gen_vips_deviate(input, &out_out)
	if ret != 0 {
		return 0, handleVipsError()
	}

	return float64(out_out), nil
}

// vipsGenDivide calls the vips divide operation.
// divide two images
func vipsGenDivide(left *C.VipsImage, right *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("divide")

	var out_out *C.VipsImage

	ret := C.gen_vips_divide(left, right, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// HistFindOptions are optional parameters for hist_find.
type HistFindOptions struct {
	Band *int
}

// vipsGenHistFind calls the vips hist_find operation.
// find image histogram
func vipsGenHistFind(input *C.VipsImage, opts *HistFindOptions) (*C.VipsImage, error) {
	incOpCounter("hist_find")

	var out_out *C.VipsImage

	var cOpts C.GenHistFindOpts
	if opts != nil {
		if opts.Band != nil {
			cOpts.has_band = 1
			cOpts.band = C.int(*opts.Band)
		}
	}

	ret := C.gen_vips_hist_find(input, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// HistFindIndexedOptions are optional parameters for hist_find_indexed.
type HistFindIndexedOptions struct {
	Combine *Combine
}

// vipsGenHistFindIndexed calls the vips hist_find_indexed operation.
// find indexed image histogram
func vipsGenHistFindIndexed(input *C.VipsImage, index *C.VipsImage, opts *HistFindIndexedOptions) (*C.VipsImage, error) {
	incOpCounter("hist_find_indexed")

	var out_out *C.VipsImage

	var cOpts C.GenHistFindIndexedOpts
	if opts != nil {
		if opts.Combine != nil {
			cOpts.has_combine = 1
			cOpts.combine = C.VipsCombine(*opts.Combine)
		}
	}

	ret := C.gen_vips_hist_find_indexed(input, index, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// HistFindNdimOptions are optional parameters for hist_find_ndim.
type HistFindNdimOptions struct {
	Bins *int
}

// vipsGenHistFindNdim calls the vips hist_find_ndim operation.
// find n-dimensional image histogram
func vipsGenHistFindNdim(input *C.VipsImage, opts *HistFindNdimOptions) (*C.VipsImage, error) {
	incOpCounter("hist_find_ndim")

	var out_out *C.VipsImage

	var cOpts C.GenHistFindNdimOpts
	if opts != nil {
		if opts.Bins != nil {
			cOpts.has_bins = 1
			cOpts.bins = C.int(*opts.Bins)
		}
	}

	ret := C.gen_vips_hist_find_ndim(input, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// HoughCircleOptions are optional parameters for hough_circle.
type HoughCircleOptions struct {
	Scale *int
	MinRadius *int
	MaxRadius *int
}

// vipsGenHoughCircle calls the vips hough_circle operation.
// find hough circle transform
func vipsGenHoughCircle(input *C.VipsImage, opts *HoughCircleOptions) (*C.VipsImage, error) {
	incOpCounter("hough_circle")

	var out_out *C.VipsImage

	var cOpts C.GenHoughCircleOpts
	if opts != nil {
		if opts.Scale != nil {
			cOpts.has_scale = 1
			cOpts.scale = C.int(*opts.Scale)
		}
		if opts.MinRadius != nil {
			cOpts.has_minRadius = 1
			cOpts.minRadius = C.int(*opts.MinRadius)
		}
		if opts.MaxRadius != nil {
			cOpts.has_maxRadius = 1
			cOpts.maxRadius = C.int(*opts.MaxRadius)
		}
	}

	ret := C.gen_vips_hough_circle(input, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// HoughLineOptions are optional parameters for hough_line.
type HoughLineOptions struct {
	Width *int
	Height *int
}

// vipsGenHoughLine calls the vips hough_line operation.
// find hough line transform
func vipsGenHoughLine(input *C.VipsImage, opts *HoughLineOptions) (*C.VipsImage, error) {
	incOpCounter("hough_line")

	var out_out *C.VipsImage

	var cOpts C.GenHoughLineOpts
	if opts != nil {
		if opts.Width != nil {
			cOpts.has_width = 1
			cOpts.width = C.int(*opts.Width)
		}
		if opts.Height != nil {
			cOpts.has_height = 1
			cOpts.height = C.int(*opts.Height)
		}
	}

	ret := C.gen_vips_hough_line(input, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenInvert calls the vips invert operation.
// invert an image
func vipsGenInvert(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("invert")

	var out_out *C.VipsImage

	ret := C.gen_vips_invert(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// LinearOptions are optional parameters for linear.
type LinearOptions struct {
	Uchar *bool
}

// vipsGenLinear calls the vips linear operation.
// calculate (a * in + b)
func vipsGenLinear(input *C.VipsImage, a []float64, b []float64, opts *LinearOptions) (*C.VipsImage, error) {
	incOpCounter("linear")

	var out_out *C.VipsImage

	var cOpts C.GenLinearOpts
	if opts != nil {
		if opts.Uchar != nil {
			cOpts.has_uchar = 1
			cOpts.uchar = C.int(boolToInt(*opts.Uchar))
		}
	}

	ret := C.gen_vips_linear(input, (*C.double)(unsafe.Pointer(&a[0])), C.int(len(a)), (*C.double)(unsafe.Pointer(&b[0])), C.int(len(b)), &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenMath calls the vips math operation.
// apply a math operation to an image
func vipsGenMath(input *C.VipsImage, math OperationMath) (*C.VipsImage, error) {
	incOpCounter("math")

	var out_out *C.VipsImage

	ret := C.gen_vips_math(input, C.VipsOperationMath(math), &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenMath2 calls the vips math2 operation.
// binary math operations
func vipsGenMath2(left *C.VipsImage, right *C.VipsImage, math2 OperationMath2) (*C.VipsImage, error) {
	incOpCounter("math2")

	var out_out *C.VipsImage

	ret := C.gen_vips_math2(left, right, C.VipsOperationMath2(math2), &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenMath2Const calls the vips math2_const operation.
// binary math operations with a constant
func vipsGenMath2Const(input *C.VipsImage, math2 OperationMath2, c []float64) (*C.VipsImage, error) {
	incOpCounter("math2_const")

	var out_out *C.VipsImage

	ret := C.gen_vips_math2_const(input, C.VipsOperationMath2(math2), (*C.double)(unsafe.Pointer(&c[0])), C.int(len(c)), &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenMatrixinvert calls the vips matrixinvert operation.
// invert a matrix
func vipsGenMatrixinvert(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("matrixinvert")

	var out_out *C.VipsImage

	ret := C.gen_vips_matrixinvert(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenMatrixmultiply calls the vips matrixmultiply operation.
// multiply two matrices
func vipsGenMatrixmultiply(left *C.VipsImage, right *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("matrixmultiply")

	var out_out *C.VipsImage

	ret := C.gen_vips_matrixmultiply(left, right, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenMaxpair calls the vips maxpair operation.
// maximum of a pair of images
func vipsGenMaxpair(left *C.VipsImage, right *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("maxpair")

	var out_out *C.VipsImage

	ret := C.gen_vips_maxpair(left, right, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenMinpair calls the vips minpair operation.
// minimum of a pair of images
func vipsGenMinpair(left *C.VipsImage, right *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("minpair")

	var out_out *C.VipsImage

	ret := C.gen_vips_minpair(left, right, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenMultiply calls the vips multiply operation.
// multiply two images
func vipsGenMultiply(left *C.VipsImage, right *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("multiply")

	var out_out *C.VipsImage

	ret := C.gen_vips_multiply(left, right, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenProfile calls the vips profile operation.
// find image profiles
func vipsGenProfile(input *C.VipsImage) (*C.VipsImage, *C.VipsImage, error) {
	incOpCounter("profile")

	var out_columns *C.VipsImage
	var out_rows *C.VipsImage

	ret := C.gen_vips_profile(input, &out_columns, &out_rows)
	if ret != 0 {
		return nil, nil, handleImageError(out_columns)
	}

	return out_columns, out_rows, nil
}

// vipsGenProject calls the vips project operation.
// find image projections
func vipsGenProject(input *C.VipsImage) (*C.VipsImage, *C.VipsImage, error) {
	incOpCounter("project")

	var out_columns *C.VipsImage
	var out_rows *C.VipsImage

	ret := C.gen_vips_project(input, &out_columns, &out_rows)
	if ret != 0 {
		return nil, nil, handleImageError(out_columns)
	}

	return out_columns, out_rows, nil
}

// vipsGenRelational calls the vips relational operation.
// relational operation on two images
func vipsGenRelational(left *C.VipsImage, right *C.VipsImage, relational OperationRelational) (*C.VipsImage, error) {
	incOpCounter("relational")

	var out_out *C.VipsImage

	ret := C.gen_vips_relational(left, right, C.VipsOperationRelational(relational), &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenRelationalConst calls the vips relational_const operation.
// relational operations against a constant
func vipsGenRelationalConst(input *C.VipsImage, relational OperationRelational, c []float64) (*C.VipsImage, error) {
	incOpCounter("relational_const")

	var out_out *C.VipsImage

	ret := C.gen_vips_relational_const(input, C.VipsOperationRelational(relational), (*C.double)(unsafe.Pointer(&c[0])), C.int(len(c)), &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenRemainder calls the vips remainder operation.
// remainder after integer division of two images
func vipsGenRemainder(left *C.VipsImage, right *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("remainder")

	var out_out *C.VipsImage

	ret := C.gen_vips_remainder(left, right, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenRemainderConst calls the vips remainder_const operation.
// remainder after integer division of an image and a constant
func vipsGenRemainderConst(input *C.VipsImage, c []float64) (*C.VipsImage, error) {
	incOpCounter("remainder_const")

	var out_out *C.VipsImage

	ret := C.gen_vips_remainder_const(input, (*C.double)(unsafe.Pointer(&c[0])), C.int(len(c)), &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenRound calls the vips round operation.
// perform a round function on an image
func vipsGenRound(input *C.VipsImage, round OperationRound) (*C.VipsImage, error) {
	incOpCounter("round")

	var out_out *C.VipsImage

	ret := C.gen_vips_round(input, C.VipsOperationRound(round), &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenSign calls the vips sign operation.
// unit vector of pixel
func vipsGenSign(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("sign")

	var out_out *C.VipsImage

	ret := C.gen_vips_sign(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenStats calls the vips stats operation.
// find many image stats
func vipsGenStats(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("stats")

	var out_out *C.VipsImage

	ret := C.gen_vips_stats(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenSubtract calls the vips subtract operation.
// subtract two images
func vipsGenSubtract(left *C.VipsImage, right *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("subtract")

	var out_out *C.VipsImage

	ret := C.gen_vips_subtract(left, right, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenSum calls the vips sum operation.
// sum an array of images
func vipsGenSum(input []*C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("sum")

	var out_out *C.VipsImage

	ret := C.gen_vips_sum((**C.VipsImage)(unsafe.Pointer(&input[0])), C.int(len(input)), &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

