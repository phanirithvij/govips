// Code generated by vipsgen. DO NOT EDIT.
package vips

// #include "gen_colour.h"
import "C"

import (
	"runtime"
	"unsafe"
)

// Ensure imports are used.
var _ = unsafe.Pointer(nil)

// vipsGenCMC2LCh calls the vips CMC2LCh operation.
// transform LCh to CMC
func vipsGenCMC2LCh(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("CMC2LCh")

	var out_out *C.VipsImage

	ret := C.gen_vips_CMC2LCh(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenCMYK2XYZ calls the vips CMYK2XYZ operation.
// transform CMYK to XYZ
func vipsGenCMYK2XYZ(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("CMYK2XYZ")

	var out_out *C.VipsImage

	ret := C.gen_vips_CMYK2XYZ(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenHSV2sRGB calls the vips HSV2sRGB operation.
// transform HSV to sRGB
func vipsGenHSV2sRGB(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("HSV2sRGB")

	var out_out *C.VipsImage

	ret := C.gen_vips_HSV2sRGB(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenLCh2CMC calls the vips LCh2CMC operation.
// transform LCh to CMC
func vipsGenLCh2CMC(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("LCh2CMC")

	var out_out *C.VipsImage

	ret := C.gen_vips_LCh2CMC(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenLCh2Lab calls the vips LCh2Lab operation.
// transform LCh to Lab
func vipsGenLCh2Lab(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("LCh2Lab")

	var out_out *C.VipsImage

	ret := C.gen_vips_LCh2Lab(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenLab2LCh calls the vips Lab2LCh operation.
// transform Lab to LCh
func vipsGenLab2LCh(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("Lab2LCh")

	var out_out *C.VipsImage

	ret := C.gen_vips_Lab2LCh(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenLab2LabQ calls the vips Lab2LabQ operation.
// transform float Lab to LabQ coding
func vipsGenLab2LabQ(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("Lab2LabQ")

	var out_out *C.VipsImage

	ret := C.gen_vips_Lab2LabQ(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenLab2LabS calls the vips Lab2LabS operation.
// transform float Lab to signed short
func vipsGenLab2LabS(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("Lab2LabS")

	var out_out *C.VipsImage

	ret := C.gen_vips_Lab2LabS(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// Lab2XYZOptions are optional parameters for Lab2XYZ.
type Lab2XYZOptions struct {
	Temp []float64
}

// vipsGenLab2XYZ calls the vips Lab2XYZ operation.
// transform CIELAB to XYZ
func vipsGenLab2XYZ(input *C.VipsImage, opts *Lab2XYZOptions) (*C.VipsImage, error) {
	incOpCounter("Lab2XYZ")

	var out_out *C.VipsImage

	var cOpts C.GenLab2XYZOpts
	var pinner runtime.Pinner
	defer pinner.Unpin()
	if opts != nil {
		if opts.Temp != nil {
			cOpts.has_temp = 1
			pinner.Pin(&opts.Temp[0])
			cOpts.temp = (*C.double)(unsafe.Pointer(&opts.Temp[0]))
			cOpts.temp_n = C.int(len(opts.Temp))
		}
	}

	ret := C.gen_vips_Lab2XYZ(input, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenLabQ2Lab calls the vips LabQ2Lab operation.
// unpack a LabQ image to float Lab
func vipsGenLabQ2Lab(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("LabQ2Lab")

	var out_out *C.VipsImage

	ret := C.gen_vips_LabQ2Lab(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenLabQ2LabS calls the vips LabQ2LabS operation.
// unpack a LabQ image to short Lab
func vipsGenLabQ2LabS(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("LabQ2LabS")

	var out_out *C.VipsImage

	ret := C.gen_vips_LabQ2LabS(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenLabQ2sRGB calls the vips LabQ2sRGB operation.
// convert a LabQ image to sRGB
func vipsGenLabQ2sRGB(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("LabQ2sRGB")

	var out_out *C.VipsImage

	ret := C.gen_vips_LabQ2sRGB(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenLabS2Lab calls the vips LabS2Lab operation.
// transform signed short Lab to float
func vipsGenLabS2Lab(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("LabS2Lab")

	var out_out *C.VipsImage

	ret := C.gen_vips_LabS2Lab(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenLabS2LabQ calls the vips LabS2LabQ operation.
// transform short Lab to LabQ coding
func vipsGenLabS2LabQ(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("LabS2LabQ")

	var out_out *C.VipsImage

	ret := C.gen_vips_LabS2LabQ(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenOklab2Oklch calls the vips Oklab2Oklch operation.
// transform Oklab to Oklch
func vipsGenOklab2Oklch(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("Oklab2Oklch")

	var out_out *C.VipsImage

	ret := C.gen_vips_Oklab2Oklch(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenOklab2XYZ calls the vips Oklab2XYZ operation.
// transform Oklab to XYZ
func vipsGenOklab2XYZ(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("Oklab2XYZ")

	var out_out *C.VipsImage

	ret := C.gen_vips_Oklab2XYZ(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenOklch2Oklab calls the vips Oklch2Oklab operation.
// transform Oklch to Oklab
func vipsGenOklch2Oklab(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("Oklch2Oklab")

	var out_out *C.VipsImage

	ret := C.gen_vips_Oklch2Oklab(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenXYZ2CMYK calls the vips XYZ2CMYK operation.
// transform XYZ to CMYK
func vipsGenXYZ2CMYK(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("XYZ2CMYK")

	var out_out *C.VipsImage

	ret := C.gen_vips_XYZ2CMYK(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// XYZ2LabOptions are optional parameters for XYZ2Lab.
type XYZ2LabOptions struct {
	Temp []float64
}

// vipsGenXYZ2Lab calls the vips XYZ2Lab operation.
// transform XYZ to Lab
func vipsGenXYZ2Lab(input *C.VipsImage, opts *XYZ2LabOptions) (*C.VipsImage, error) {
	incOpCounter("XYZ2Lab")

	var out_out *C.VipsImage

	var cOpts C.GenXYZ2LabOpts
	var pinner runtime.Pinner
	defer pinner.Unpin()
	if opts != nil {
		if opts.Temp != nil {
			cOpts.has_temp = 1
			pinner.Pin(&opts.Temp[0])
			cOpts.temp = (*C.double)(unsafe.Pointer(&opts.Temp[0]))
			cOpts.temp_n = C.int(len(opts.Temp))
		}
	}

	ret := C.gen_vips_XYZ2Lab(input, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenXYZ2Oklab calls the vips XYZ2Oklab operation.
// transform XYZ to Oklab
func vipsGenXYZ2Oklab(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("XYZ2Oklab")

	var out_out *C.VipsImage

	ret := C.gen_vips_XYZ2Oklab(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenXYZ2Yxy calls the vips XYZ2Yxy operation.
// transform XYZ to Yxy
func vipsGenXYZ2Yxy(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("XYZ2Yxy")

	var out_out *C.VipsImage

	ret := C.gen_vips_XYZ2Yxy(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenXYZ2scRGB calls the vips XYZ2scRGB operation.
// transform XYZ to scRGB
func vipsGenXYZ2scRGB(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("XYZ2scRGB")

	var out_out *C.VipsImage

	ret := C.gen_vips_XYZ2scRGB(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenYxy2XYZ calls the vips Yxy2XYZ operation.
// transform Yxy to XYZ
func vipsGenYxy2XYZ(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("Yxy2XYZ")

	var out_out *C.VipsImage

	ret := C.gen_vips_Yxy2XYZ(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenDE00 calls the vips dE00 operation.
// calculate dE00
func vipsGenDE00(left *C.VipsImage, right *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("dE00")

	var out_out *C.VipsImage

	ret := C.gen_vips_dE00(left, right, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenDE76 calls the vips dE76 operation.
// calculate dE76
func vipsGenDE76(left *C.VipsImage, right *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("dE76")

	var out_out *C.VipsImage

	ret := C.gen_vips_dE76(left, right, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenDECMC calls the vips dECMC operation.
// calculate dECMC
func vipsGenDECMC(left *C.VipsImage, right *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("dECMC")

	var out_out *C.VipsImage

	ret := C.gen_vips_dECMC(left, right, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenFloat2rad calls the vips float2rad operation.
// transform float RGB to Radiance coding
func vipsGenFloat2rad(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("float2rad")

	var out_out *C.VipsImage

	ret := C.gen_vips_float2rad(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// IccExportOptions are optional parameters for icc_export.
type IccExportOptions struct {
	Pcs *int
	Intent *Intent
	BlackPointCompensation *bool
	OutputProfile *string
	Depth *int
}

// vipsGenIccExport calls the vips icc_export operation.
// output to device with ICC profile
func vipsGenIccExport(input *C.VipsImage, opts *IccExportOptions) (*C.VipsImage, error) {
	incOpCounter("icc_export")

	var out_out *C.VipsImage

	var cOpts C.GenIccExportOpts
	if opts != nil {
		if opts.Pcs != nil {
			cOpts.has_pcs = 1
			cOpts.pcs = C.VipsPCS(*opts.Pcs)
		}
		if opts.Intent != nil {
			cOpts.has_intent = 1
			cOpts.intent = C.VipsIntent(*opts.Intent)
		}
		if opts.BlackPointCompensation != nil {
			cOpts.has_blackPointCompensation = 1
			cOpts.blackPointCompensation = C.int(boolToInt(*opts.BlackPointCompensation))
		}
		if opts.OutputProfile != nil {
			cOpts.has_outputProfile = 1
			tmp_outputProfile := C.CString(*opts.OutputProfile)
			defer C.free(unsafe.Pointer(tmp_outputProfile))
			cOpts.outputProfile = tmp_outputProfile
		}
		if opts.Depth != nil {
			cOpts.has_depth = 1
			cOpts.depth = C.int(*opts.Depth)
		}
	}

	ret := C.gen_vips_icc_export(input, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// IccImportOptions are optional parameters for icc_import.
type IccImportOptions struct {
	Pcs *int
	Intent *Intent
	BlackPointCompensation *bool
	Embedded *bool
	InputProfile *string
}

// vipsGenIccImport calls the vips icc_import operation.
// import from device with ICC profile
func vipsGenIccImport(input *C.VipsImage, opts *IccImportOptions) (*C.VipsImage, error) {
	incOpCounter("icc_import")

	var out_out *C.VipsImage

	var cOpts C.GenIccImportOpts
	if opts != nil {
		if opts.Pcs != nil {
			cOpts.has_pcs = 1
			cOpts.pcs = C.VipsPCS(*opts.Pcs)
		}
		if opts.Intent != nil {
			cOpts.has_intent = 1
			cOpts.intent = C.VipsIntent(*opts.Intent)
		}
		if opts.BlackPointCompensation != nil {
			cOpts.has_blackPointCompensation = 1
			cOpts.blackPointCompensation = C.int(boolToInt(*opts.BlackPointCompensation))
		}
		if opts.Embedded != nil {
			cOpts.has_embedded = 1
			cOpts.embedded = C.int(boolToInt(*opts.Embedded))
		}
		if opts.InputProfile != nil {
			cOpts.has_inputProfile = 1
			tmp_inputProfile := C.CString(*opts.InputProfile)
			defer C.free(unsafe.Pointer(tmp_inputProfile))
			cOpts.inputProfile = tmp_inputProfile
		}
	}

	ret := C.gen_vips_icc_import(input, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenRad2float calls the vips rad2float operation.
// unpack Radiance coding to float RGB
func vipsGenRad2float(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("rad2float")

	var out_out *C.VipsImage

	ret := C.gen_vips_rad2float(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenSRGB2HSV calls the vips sRGB2HSV operation.
// transform sRGB to HSV
func vipsGenSRGB2HSV(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("sRGB2HSV")

	var out_out *C.VipsImage

	ret := C.gen_vips_sRGB2HSV(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenSRGB2scRGB calls the vips sRGB2scRGB operation.
// convert an sRGB image to scRGB
func vipsGenSRGB2scRGB(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("sRGB2scRGB")

	var out_out *C.VipsImage

	ret := C.gen_vips_sRGB2scRGB(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// ScRGB2BWOptions are optional parameters for scRGB2BW.
type ScRGB2BWOptions struct {
	Depth *int
}

// vipsGenScRGB2BW calls the vips scRGB2BW operation.
// convert scRGB to BW
func vipsGenScRGB2BW(input *C.VipsImage, opts *ScRGB2BWOptions) (*C.VipsImage, error) {
	incOpCounter("scRGB2BW")

	var out_out *C.VipsImage

	var cOpts C.GenScRGB2BWOpts
	if opts != nil {
		if opts.Depth != nil {
			cOpts.has_depth = 1
			cOpts.depth = C.int(*opts.Depth)
		}
	}

	ret := C.gen_vips_scRGB2BW(input, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenScRGB2XYZ calls the vips scRGB2XYZ operation.
// transform scRGB to XYZ
func vipsGenScRGB2XYZ(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("scRGB2XYZ")

	var out_out *C.VipsImage

	ret := C.gen_vips_scRGB2XYZ(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// ScRGB2sRGBOptions are optional parameters for scRGB2sRGB.
type ScRGB2sRGBOptions struct {
	Depth *int
}

// vipsGenScRGB2sRGB calls the vips scRGB2sRGB operation.
// convert scRGB to sRGB
func vipsGenScRGB2sRGB(input *C.VipsImage, opts *ScRGB2sRGBOptions) (*C.VipsImage, error) {
	incOpCounter("scRGB2sRGB")

	var out_out *C.VipsImage

	var cOpts C.GenScRGB2sRGBOpts
	if opts != nil {
		if opts.Depth != nil {
			cOpts.has_depth = 1
			cOpts.depth = C.int(*opts.Depth)
		}
	}

	ret := C.gen_vips_scRGB2sRGB(input, &out_out, &cOpts)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

// vipsGenUhdr2scRGB calls the vips uhdr2scRGB operation.
// transform uhdr to scRGB
func vipsGenUhdr2scRGB(input *C.VipsImage) (*C.VipsImage, error) {
	incOpCounter("uhdr2scRGB")

	var out_out *C.VipsImage

	ret := C.gen_vips_uhdr2scRGB(input, &out_out)
	if ret != 0 {
		return nil, handleImageError(out_out)
	}

	return out_out, nil
}

